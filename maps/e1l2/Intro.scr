//=========================================================================
InitIntro:
//=========================================================================
{
	$missionfailtrigger nottriggerable

	if (level.hackIntro == 1){
		$tank1.target = NULL
		$tank2.target = NULL
		$tank3.target = NULL
	}
	
	level.dontdropweapons = 1
	drawhud 0    //turn off the hud for the intro
	
	for (local.i=1;local.i<$mg42.size+1;local.i++){
		// level.spot_burstmin level.spot_burstmax level.spot_burstdownmin level.spot_burstdownmax	
		$mg42[local.i] burstfiresettings 1 3 1.5 3
		$mg42[local.i] maxyawoffset 60.0
		$mg42[local.i] pitchcaps "-20 20 0"
		$mg42[local.i] convergetime 0.25

		switch (level.skill){
			case 0:
				$mg42[local.i] aibulletspread 450 275
				break
			case 1:
				$mg42[local.i] aibulletspread 400 225
				break
			case 2:
				$mg42[local.i] aibulletspread 300 125
				break
		}
	}
	
	$firstmg42 burstfiresettings 1 3 1.5 3
	$firstmg42 maxyawoffset 60.0
	$firstmg42 pitchcaps "-20 20 0"
	$firstmg42 convergetime 0.25

	switch (level.skill){
		case 0:
			$firstmg42 aibulletspread 450 275
			break
		case 1:
			$firstmg42 aibulletspread 400 225
			break
		case 2:
			$firstmg42 aibulletspread 300 125
			break
	}
	
	

	for(local.i = 1; local.i <= $mg42.size; local.i++){
		if($mg42[local.i].find_name == "firstmg42"){
			if !($mg42guy){
			   $($mg42[local.i].target) targetname "mg42guy"
			}

			$mg42[local.i] targetname "firstmg42"		
		}
	}
	
	if($firstmg42 == NIL){
		$mg42[1] targetname "firstmg42" 
	}

	$mg42guy ai_off
	
	level.tank1trigger = waitthread global/FindTrigger.scr::FindTrigger "tank1trigger"
	level.tank2trigger = waitthread global/FindTrigger.scr::FindTrigger "tank2trigger"
	level.tank3trigger = waitthread global/FindTrigger.scr::FindTrigger "tank3trigger"
	level.tank4trigger = waitthread global/FindTrigger.scr::FindTrigger "jeeptrigger"

	for(local.i = 1; local.i <= $tank3guys.size; local.i++){
		$tank3guys[local.i] attackplayer
	}

	$jeep.speed 		= 100
	$jeep.accel 		= 100
	$jeep.trucktype 	= "jeep"
	$jeep.drivermodel 	= $infantry[2].model
	$jeep.takedamage 	= 0

	$commander rendereffects "-shadow"
	$commander exec global/disable_ai.scr
	$commander physics_off
	$commander thread global/LoopAnim.scr::LoopAnim A_12_Fuches_idle
	$commander nodamage
	$commander angles ( 0 0 0 )
	$commander attach $jeep passenger0 1
	$commander gun "thompson"
	$commander exec coop_mod/replace.scr::holster //chrissstrahl - fix for multiplayer
	$commander avoidplayer 0

	$jeep.unloadwhendone = 0
	$tank1.speed = 15
	$tank1.accel = 15
	
	$tank1.tank_stunned_time = 0
	$tank2.tank_stunned_time = 0
	$tank3.tank_stunned_time = 0
	
	$tank2.speed = 15
	$tank2.accel = 15
	$tank3.speed = 15
	$tank3.accel = 15
	
	$tank1.health  = 3000
	$tank1.myenemy = $tank1guys
	$tank2.health  = 3000
	$tank3.health  = 3000

	$tank1.origin = $tank1path.origin
	$tank2.origin = $tank2path.origin
	$tank3.origin = $tank3path.origin
	$jeep.origin  = $jeeppath.origin
	
	$tank2.myenemy = NULL
	$tank3.myenemy = NULL
	$tank1.myenemy = NULL
	$tank3.health  = 10000
	
	trigger level.tank1trigger
	trigger level.tank2trigger
	trigger level.tank3trigger
	trigger level.tank4trigger
	waitframe

	$commander threatbias ignoreme
	$jeep_passenger threatbias ignoreme
	$jeep_passenger exec global/disable_ai.scr
	$jeep nodamage
	$tank1 nodamage

	$tank1.mineclearing = spawn script_model model vehicles/US_V_MineClearing.tik
	$tank1.mineclearing attach $tank1 origin 1
	$tank2.mineclearing = spawn script_model model vehicles/US_V_MineClearing.tik
	$tank2.mineclearing attach $tank2 origin 1

	
	$tank2 nodamage
	$tank3 nodamage
	level.pinBackTanks = 0
	$tank2 thread IfDestroyedEndMission
	
	for(local.i =1;	local.i <= $tank1guys.size; local.i++){
		$tank1guys[local.i] dontdropweapons
		$tank1guys[local.i] thread DontdropHealth
	}

	for(local.i =1;	local.i <= $tank3guys.size; local.i++){
		$tank3guys[local.i] dontdropweapons
		$tank3guys[local.i] thread DontdropHealth
	}

	for(local.i =1;	local.i <= $tank1guys3.size; local.i++){
		$tank1guys3[local.i] dontdropweapons
		$tank1guys3[local.i] thread DontdropHealth
	}
	
	$tank2 thread TanksKill $tank1guys
	$infantry[1] nodamage
	$infantry[2] nodamage
	
	//set accuracy...make guys who dont have to reach end easier to kill 
	for (local.i = 1; local.i <= $infantry.size; local.i++){
		$infantry[local.i].accuracy = 65

		if (local.i > 2){
			$infantry[local.i].health = 30
		}
	}
	

	// Don't allow the tower to blow up until we are ready
	local.trigger2 = waitthread global/FindTrigger.scr::FindTrigger "towerexplodertrigger"
	local.trigger2 nottriggerable

	level.artillerywhistletime = 1.8
	$parade1spawner.ai_enabled = 1 
	thread WaitArroundThread
}end

// I need to wait for the guys to spawn in before I can ask them not to drop health
//=========================================================================
WaitArroundThread:
//=========================================================================
{
	wait 8.0
	
	for(local.i =1;	local.i <= $tank1guys2.size; local.i++){
		$tank1guys2[local.i] dontdropweapons
		$tank1guys2[local.i] thread DontdropHealth
	}
}end

//=========================================================================
DontdropHealth:
//=========================================================================
{
  	self waittill death
  	self takeall
}end

// self tank attaching to
//=========================================================================
AttachTankguys local.guy:
//=========================================================================
{
	local.guy[1] notsolid
	local.guy[2] notsolid
	local.guy[1] physics_off
	local.guy[2] physics_off
	local.guy[1] exec global/disable_ai.scr
	local.guy[2] exec global/disable_ai.scr
	
	local.guy[1].angles = (0 0 0)
	local.guy[1] attach self origin 
	local.guy[1] thread global/LoopAnim.scr::LoopAnim A_13_TankSit01		//(soldier sitting on the front left of the tank)
	local.guy[1].front = 1	

	//local.guy[1] animscript_attached A_13_TankSit01
	local.guy[2].angles = (0 0 0)
	local.guy[2] attach self origin 
	local.guy[2] thread global/LoopAnim.scr::LoopAnim A_13_TankSit02		//(soldier sitting on the back side of the tank)
	local.guy[2].front = 0
}end

// self tank attaching to
//=========================================================================
DettachTankguys local.guy:
//=========================================================================
{
	//iprintln ( local.guy[1].targetname + ": first guy: " +  local.guy[1].front)
	//iprintln ( "second guy: " +  local.guy[2].front)
	
	local.guy[1] waitthread global/LoopAnim.scr::LoopAnimStop
	local.guy[1] detach

	if(local.guy[1].front == 1){
		local.guy[1] anim A_13_TankJump01	// (soldier jumping from the front left side of the tank)
	}
	else{
		local.guy[1] anim A_13_TankJump02 // (soldier jumping from the back side of the tank)
	}

	local.guy[1] waittill animdone
	local.guy[1].origin = self.origin + (218.9301418 -0.003 216.4666275) 
	
	//local.origin = local.guy[1] gettagposition "origin"
	//local.guy[1].origin = local.origin
	
	local.guy[2] waitthread global/LoopAnim.scr::LoopAnimStop
	waitframe
	
	if(local.guy[2].front == 1){
		local.guy[2] anim A_13_TankJump01	// (soldier jumping from the front left side of the tank)
	}
	else{
		local.guy[2] anim A_13_TankJump02 // (soldier jumping from the back side of the tank)
	}
	
	local.guy[2] waittill animdone
	local.guy[2] detach
	//local.origin = local.guy[2] gettagposition "origin"
	//local.guy[2].origin = local.origin
	//println "DEBUG: minesweeper attach finish"
}end

//=========================================================================
IfPlayerRetreatEndMission:
//=========================================================================
{
	//chrissstrahl - coop - not sure what to do here, I don't want a single dick to fail all other players
	if(level.gametype != 0){
		end
	}
	$missionfailtrigger triggerable
	$missionfailtrigger waittill trigger
	iprintln (loc_convert_string "You failed to protect the Minesweeper Tank.")
	missionfailed
}end

//=========================================================================
IfDestroyedEndMission:
//=========================================================================
{
	self waittill death
	wait 3

	iprintln (loc_convert_string "You failed to protect the Minesweeper Tank.")
	//chrissstrahl - keep sp
	if(level.gametype == 0){
		missionfailed
	}
	//chrissstrahl - coop - fail mission in coop
	else{
		exec coop_mod/replace.scr::missionfailed
	}
}end

//=========================================================================
DoIntro:
//=========================================================================
{
	if (level.hackIntro == 1){
		iprintln "Skipping intro --hack"
		local.person = spawn script_model model models/human/allied_uk_capt-paratrooper.tik origin $($jeeppath.target).origin "targetname" "mrinvisible2"
		local.person hide
		$mrinvisible2 physics_on
		$mrinvisible2 notsolid
		
		for(local.i = 1; local.i <= $infantry.size; local.i++){
			$infantry[local.i].destination		= $mrinvisible2
			$infantry[local.i].friendtype		= 1
			$infantry[local.i].waittime			= 3
			//$infantry[local.i].walkto         = 1
			// stagger how far away they keep from their destinations
			$infantry[local.i].distance			= 90
			// setup the friendlies to follow the player...
			$infantry[local.i]   thread global/friendly.scr::friendlythink
		}

		$jeep.origin  = ( -2685.867920 -237.092422 	176.429779)
		$jeep.angles  = ( 0.000000 		226.196350 	0.000000)
		$tank1.origin = ( -3658.976318 -2076.060303 256.989014)
		$tank1.angles = ( 359.000000 	265.748627 	357.000000)
		$tank2.origin = ( -3142.760986 -1207.429443 171.611725)
		$tank2.angles = ( 0.000000 		229.750336 	5.000000)
		$tank3.origin = ( -2792.099609 -686.497131 	184.322220)
		$tank3.angles = ( 5.000000  	227.330368 	11.000000)
		$jeep driveNoWait $jeepretreat -200 100 20 20
		thread jeepGo

		//$jeep anim start_wheels
		$jeep anim jeep_idle_drive
		local.findname = waitthread global/FindTrigger.scr::FindTrigger "parade1trigger"
		trigger local.findname
		level.KillMg42Nest = 0
		thread ReplaceMg42guy
		thread JeepStop $mrinvisible2
		
		$tank2 thread TanksKillParade $parade1spawner_paradeguy 5000 level.KillMg42Nest
		$mrinvisible2.origin = $infantryrallypoint.origin

		for(local.i = 1; local.i <= $infantry.size; local.i++){
			$infantry[local.i] exec global/disable_ai.scr
			$infantry[local.i] thread IfHurtWakeUpOrClose
		}
		
		waitthread playerExitTank
		drawhud 1   //turn the hud on after the intro
		level.dontdropweapons = 0
		end
	}  //END HACK SECTION

	$tank2 nodamage
	$tank2 setcollisionentity $sherman_sweeper_collide_on
	$tank2.minesweeperOn = 0
	$tank2 thread maps/e1l2/Crab.scr::minesweeperDamagePlayer $minesweeperdamage
	
	//chrissstrahl - keep for singleplayer
	if(level.gametype == 0){
		$player.viewangles = (0 -20 0)
	}
	waitthread PlayerOnJeep
		
	switch (level.skill){
		case 0:
			$tank2.health = 5500
			//iprintln "DEBUG: easy"
			break
		case 1:
			$tank2.health = 4000
			//iprintln "DEBUG: medium"
			break
		case 2:
			$tank2.health = 2500
			//iprintln "DEBUG: hard"
			break
	}
	
	//	$jeep_passenger.no_idle = 1
	//	$jeep_passenger thread global/LoopAnim.scr::LoopAnim A_22_driving_idle
	level.maxTilt = 10

	//chrissstrahl - keep for singleplayer
	if(level.gametype == 0){
		$player physics_on
		$player holster
	}
	wait 2

	//chrissstrahl - keep for singleplayer
	if(level.gametype == 0){
		$player physics_off
	}
	
	//chrissstrahl - debug test, do not run this code during debug
	if( level.coop_debugLevel == NIL ){
		//thread global/MaintainCamera.scr::StartMaintainCamera $jeep //[202][hotfix] Smithy
	}

	local.person = spawn script_model model models/human/allied_uk_capt-paratrooper.tik origin $($jeeppath.target).origin "targetname" "mrinvisible2"
	local.person hide

	$mrinvisible2 physics_on
	$mrinvisible2 notsolid
	$mrinvisible2.origin = $($jeeppath.target).origin + (0 0 80)
	
	level.infantryfollow = $jeep
	$jeep thread InfantryFollowingBehind $jeeppath $mrinvisible2 100
	
	for(local.i = 1; local.i <= $infantry.size; local.i++){
		switch (local.i){
			case 1:
				local.distance = 90
				break
			case 2:
				local.distance = 150
				break
			case 3:
				local.distance = 200
				break
			case 4:
				local.distance = 175
				break
		}	
		
		$infantry[local.i].distance = local.distance
		$infantry[local.i].destination		= $mrinvisible2
		$infantry[local.i].friendtype		= 1
		$infantry[local.i].waittime			= 3
		//$infantry[local.i].walkto         = 1
		// stagger how far away they keep from their destinations
		//$infantry[local.i].distance		= 90
		// setup the friendlies to follow the player...
		$infantry[local.i] thread global/friendly.scr::friendlythink
	}
	
	$tank2 thread aimAtNothingYou
	$tank3 thread aimAtNothingYou

	$tank1.mineclearing anim start
	$tank1.mineclearing waittill animdone
	$tank1.mineclearing anim spin
	
	thread introDialogue
	waitthread goTanksGo

	level.pinBackTanks = 1
	thread startPinBackTanks
	wait 1

	local.findname = waitthread global/FindTrigger.scr::FindTrigger "parade1trigger"
	trigger local.findname
	level.KillMg42Nest = 0
	thread ReplaceMg42guy
	thread JeepStop $mrinvisible2
	waitthread runAway

	
	waitthread JeepDialogue
	waitframe
	
	for (local.i = 1; local.i <= $infantry.size; local.i++){
		$infantry[local.i].accuracy = 15
	}
		
	waitthread playerExitTank
	
	drawhud 1
	level.dontdropweapons = 0
	
	//chrissstrahl - coop - do this only in sp
	if( level.gametype == 0){
		$player useweaponclass smg
	}
	
	waitthread global/items.scr::add_item "explosive"
	
	$jeep nodamage
	wait 2.0

	$mrinvisible2.origin = $infantryrallypoint.origin

	for(local.i = 1; local.i <= $infantry.size; local.i++){
		$infantry[local.i] exec global/disable_ai.scr
		$infantry[local.i] thread IfHurtWakeUpOrClose
	}

	//local.ambushtrigger = waitthread global/FindTrigger.scr::FindTrigger "ambushguystrigger"
	//trigger local.ambushtrigger
	wait 1.0

	$tank2 takedamage
	$tank2 thread TanksKillParade $parade1spawner_paradeguy 5000 level.KillMg42Nest
	thread CleanupIntro
	thread IfEveryoneDeadAimAtTurrets
}end

// This counts who is alive and when it is 0 then it has them  aim at a random point until the level.fakeshooting variable is 
// set to 0 only counts ambushguys and "parade1spawner_paradeguy"s
// level.fakeshooting is set to 0 when the artillery objective is done. they only aim at artillery1 and 2
//=========================================================================
IfEveryoneDeadAimAtTurrets:
//=========================================================================
{
	local.count = 0

	for(local.i = 1; local.i <= $parade1spawner_paradeguy.size; local.i++){
		if(isalive $parade1spawner_paradeguy[local.i]){
			local.count++
		}
	}

	for(local.i = 1; local.i <= $ambushguys.size; local.i++){
		if(isalive $ambushguys[local.i]){
			local.count++
		}
	}

	while(local.count > 0){
			local.count = 0

			for(local.i = 1; local.i <= $parade1spawner_paradeguy.size; local.i++){
				if(isalive $parade1spawner_paradeguy[local.i]){
					local.count++
				}
			}
				
			for(local.i = 1; local.i <= $ambushguys.size; local.i++){
				if(isalive $ambushguys[local.i]){
					local.count++
				}
			}
			wait 0.5
		}
	// iprintln "Did this work?"
	/*
	local.person = spawn models/human/german_wehrmact_soldier.tik origin ( -4494 -3627 970) "targetname" "EvilInvisibleMan"
	$EvilInvisibleMan ai_off
	$EvilInvisibleMan nodamage
	$EvilInvisibleMan threatbias 1000000	
		$EvilInvisibleMan origin ( -4552 -2976 734)
	*/
	
	level.fakeshooting = 1

	for(local.i = 1; local.i <= $infantry.size; local.i++){
		$infantry[local.i] thread AimAtGuns $("artillery" + (randomint(2) + 1))
	}
}end

//=========================================================================
AimAtGuns local.target:
//=========================================================================
{
	// iprintln level.fakeshooting
	local.targetname = local.target.targetname

	while(isalive self && level.fakeshooting == 1 && local.target)
	{
		self turnto local.target
		self aimat local.target
		self setaimtarget local.target 1
		self exec global/shoot.scr
		wait (randomfloat(2) + 0.1)
	}

	self turnto NULL
	self aimat NULL
	// iprintln "done shooting"
}end

//=========================================================================
IfHurtWakeUpOrClose:
//=========================================================================
{
	//iprintln "IfHurtWakeUp"
	self thread WakeUpWhenClose
	self waittill pain
	self.hurt = 1

	//iprintln "IfHurtWakeUp"
	self exec global/enable_ai.scr
}end

//=========================================================================
WakeUpWhenClose:
//=========================================================================
{
	//iprintln "WakeUpWhenClose"
	local.dist = 1000

	while(self && local.dist > self.distance+2)	{
		if(self.hurt == 1){
			self.hurt = 0
			end
		}

		local.dist = vector_length(self.origin - $mrinvisible2.origin)
		waitframe
	}

	if(self){
		self exec global/enable_ai.scr
	}
}end

//=========================================================================
JeepDialogue:
//=========================================================================
{
	$mrinvisible2.origin = $infantryrallypoint.origin

	local.tankSpeed 		= 400
	local.tankAcceleration 	= 200

	//iprintln "DEBUG: Jeep Dialogue"
	//$jeep thread global/autotruck.scr::StartTruck $jeeppullup local.tankSpeed  local.tankAcceleration

	$jeep driveNoWait $jeeppullup local.tankSpeed local.tankAcceleration 256 256
	thread jeepGo

	$jeep anim jeep_idle_drive
	wait 2.0
	
	$jeep modifydrive 100 100 256
	$jeep waittill drive
	thread jeepStop

	$jeep anim jeep_idle_still
	$jeep.stopped = 1
	
	$commander ai_on
	$commander waitthread global/LoopAnim.scr::LoopAnimStop
	$commander anim A_12_FuchesTalk04 // Sergeant Baker, push ahead and take out their artillery, then link back up with this unit when you're done!
	$commander waittill animdone
	$commander lookat NULL
	$commander thread global/LoopAnim.scr::LoopAnim A_12_Fuches_idle
	
	//$commander ai_off
	if( $jeepretreat){
		thread waitfordonedrive
	}
}end



// I broke this thread off so that I could wait for the jeep to stop moving before I bring the troops up
waitfordonedrive:
// TOO FAST
//		iprintln "DEBUG: going back"
		$jeep connect_paths
		$jeep driveNoWait $jeepretreat -200 100 20 20
		thread jeepGo
//		$jeep anim wheels_start
		wait 2.0
		$jeep modifydrive -80 100 256
		//$jeep thread global/autotruck.scr::StartTruck $jeepretreat -20 100
		$jeep waittill drive
		thread jeepStop
//		$jeep anim wheels_stop
//		iprintln "DEBUG: back"
		$jeep disconnect_paths
		
		local.stop = 0

		for(local.i = 1; local.i <= $infantry.size; local.i++)
			$infantry[local.i] exec global/enable_ai.scr
End

JeepStop local.guytofollow:
	if($jeep.stopped == 1)
		End
	
	local.dist = 1000
	while(local.dist > 400)
		{
			//iprintln ("Distance to stop: " + local.dist)
			local.dist = vector_length($jeep.origin - $jeeppullup.origin)
			waitframe
		}
	$jeep fullstop	
	thread jeepStop
//	$jeep anim stop_wheels
	$jeep.stopped = 1	 
	// $mrinvisible2.origin = $infantrysafepoint.origin
	wait 1.0
	$(local.guytofollow).origin = $infantrysafepoint.origin
End


// $jeep thread InfantryFollowingTank $infantry $tank4path 
// so self is the tank
// local.guys are the guys following the tank
// local.path is the first node in the path the tank is driving
InfantryFollowingTank local.guys local.path local.guytofollow:
	
	//iprintln "How often do you happen?"
	
	local.nextnode = $(local.path).target
	local.vehiclefollowing = self
	while($(local.nextnode) != NULL)
	{
		if(level.infantryfollow != self)
			local.vehiclefollowing = level.infantryfollow
		if($(local.nextnode) == NULL)
			End
		wait 1.0
		if(self.stopped == 1)
			End
		local.dist = 1000
		local.lastdist = 1000
		while(local.dist > 300)
			{
				local.dist = vector_length($(local.vehiclefollowing).origin - $(local.nextnode).origin)
				if(local.dist > local.lastdist)
					local.dist = -10
				waitframe
				//iprintln ("local.dist = " + local.dist)
				local.lastdist = local.dist
			
			}
	   // iprintln "How often do you go?"
		if(local.dist != -10)
		{
			$(local.guytofollow).origin = $(local.nextnode).origin + (0 0 80)
			wait 2.0	
		}
		
		local.nextnode = $(local.nextnode).target
	}
	//iprintln "how quickly do you finish?"
End

// $jeep thread InfantryFollowingBehind $tank4path $mrinvisible2
// so self is the tank
// local.guys are the guys following the tank
// local.path is the first node in the path the tank is driving
InfantryFollowingBehind local.path local.guytofollow local.scale local.wait:

	println "*********************InfantryFollowingBehind***********************"
	
	if(local.wait == NIL)
		local.wait = 3.0
	
	
	if(local.scale  == NIL)
		local.scale = 200
	for(local.i = 1; local.i <= $infantry.size; local.i++)
		$infantry[local.i] connect_paths	
	
	
	local.vehiclefollowing = self
	local.spawnpoint = spawn script_origin
	while(self.stopped != 1)
	{
		if(level.infantryfollow != self)
			local.vehiclefollowing = level.infantryfollow
		
		local.vector = angles_toforward $(local.vehiclefollowing).angles
		local.vector = vector_scale local.vector local.scale
		local.spawnpoint.origin = $(local.vehiclefollowing).origin - local.vector
			
		$(local.guytofollow).origin = local.spawnpoint.origin + (0 0 80)
		wait local.wait	
		
	}
	//iprintln "how quickly do you finish?"
End


//--------------------------------------------
PlayerOnJeep:
//--------------------------------------------
	//chrissstrahl - keep for singleplayer
	if(level.gametype == 0){
		$player notsolid
		$player.angles = "0 0 0"
	}

//	local.tankseat = spawn script_origin
//	local.tankseat attach $jeep driver 1 ( -50 -20 -40 )
//	$player glue local.tankseat
	
	local.tankseat = spawn script_origin targetname jeepseat //[202][hotfix] Smithy - give it a targetname
	local.tankseat attach $jeep passenger1 1 ( 0 0 -50 )
	//chrissstrahl - keep for singleplayer
	if(level.gametype == 0){
		$player glue local.tankseat
		$player physics_off
	}
	//chrissstrahl - multiplayer/coop
	else{
		//chrissstrahl - debug test, do not run this code during debug
		if( level.coop_debugLevel == NIL ){
			level.coop_playerGlue = 1
			exec coop_mod/replace.scr::hide	
			exec coop_mod/replace.scr::glue local.tankseat 0
			thread coop_startJeepSpawnManager
		}
	}
end

//[202][hotfix] Smithy
//============================================================================
coop_startJeepSpawnManager:{
//============================================================================	
	if (level.thread["coop_startJeepSpawnManager"]){ end }
	
	level.thread["coop_startJeepSpawnManager"] = local
	
	//iprintlnbold_noloc("starting coop_startJeepSpawnManager")
		
	if ($jeepCamera){
		$jeepCamera delete //start the number of cams at 0
	}
	
	//spawn any cameras we need for players that may have spawned before the handler started
	waitthread coop_startJeepCameras
	thread coop_maintainJeepCameras
	
	//the main spawn handler during the scene
	while (1){
		level waittill playerspawn
		println("ADDING PLAYER TO CAM (playerspawn)")
		group.player = parm.other
		
		group.player hide
		group.player notsolid	
		//group.player.viewangles = $jeep.angles
		//group.player.viewangles += ( 0 18 0 )	
		
		if (!group.player.isSpectator){ 				
			thread coop_spawnJeepCamera
			thread coop_startJeepCamera
		}
	}	
}end

//[202][hotfix] Smithy - stop the jeep scene spawn handler
//============================================================================
coop_stopJeepSpawnManager:{
//============================================================================
	if (level.thread["coop_startJeepSpawnManager"]){ level.thread["coop_startJeepSpawnManager"] delete }		
	if (level.thread["coop_maintainJeepCameras"]){ level.thread["coop_maintainJeepCameras"] delete }
	thread coop_stopJeepCameras
}end

//============================================================================
coop_startJeepCameras:{
//============================================================================
	for (local.i = 1; local.i <= $player.size; local.i++){
		group.player = $player[local.i]
		if (!group.player.jeepCamera){
			println("ADDING PLAYER TO CAM (coop_startJeepSpawnManager)")
			thread coop_spawnJeepCamera
			thread coop_startJeepCamera
		}
	}
}end

//============================================================================
coop_stopJeepCameras:{
//============================================================================
	cueplayer
	$jeepCamera delete
}end

//[202][hotfix] Smithy - spawn a camera for a player and set it up in jeep
//============================================================================
coop_spawnJeepCamera:
//============================================================================	
	if (!group.player.jeepCamera){
		local.cam = spawn Camera targetname jeepCamera 	//give them all the same name so they are handled in the targetname array
		local.cam showquakes 1
		local.cam.origin = $jeepseat.origin + (0 0 85)
		local.cam bind $jeep
		local.cam.player = group.player
		group.player.jeepCamera = local.cam
		group.player.oldViewAngles = group.player.viewangles		
	}
end

//[202][hotfix] Smithy - make them look through their jeep camera
//============================================================================
coop_startJeepCamera:{
//============================================================================	
	if (group.player.jeepCamera && !group.player.inJeepCamera){
		group.player.inJeepCamera = game.true
			
		local.name = ("jeepCamera_" + group.player.entnum)
		local.cam = group.player.jeepCamera
		local.cam targetname local.name
		//local.cam.angles = $jeep gettagangles driver_seat
		
		local.camerause = spawn trigger_camerause target local.name	
		local.camerause doUse group.player
		local.camerause delete
		
		//[202] Smithy - set targetname back to original so it gets added back to the array
		local.cam targetname "jeepCamera"
	}
}end

//[202][hotfix] Smithy - make them look through their jeep camera
//============================================================================
coop_stopJeepCamera:{
//============================================================================	
	if (group.player.jeepCamera && group.player.inJeepCamera){
		group.player.inJeepCamera = game.false
			
		local.name = ("jeepCamera_" + group.player.entnum)
		local.cam = group.player.jeepCamera
		local.cam targetname local.name
		
		local.camerause = spawn trigger_camerause target local.name	
		local.camerause doUse group.player
		local.camerause delete
		
		//[202] Smithy - set targetname back to original so it gets added back to the array
		local.cam targetname "jeepCamera"
	}
}end

//[202][hotfix] Smithy
//=========================================================================
coop_maintainJeepCameras:{
//=========================================================================
	if (level.thread["coop_maintainJeepCameras"]){ end }
	level.thread["coop_maintainJeepCameras"] = local
		
	while (1) {
		//loop over all cameras
		for (local.i = 1; local.i <= $jeepCamera.size; local.i++){
			local.cam = $jeepCamera[local.i]
			group.player = local.cam.player

			
			if (isAlive group.player && !group.player.isSpectator){
				if (!group.player.inJeepCamera){
					//println "STARTING JEEP CAM"
					thread coop_startJeepCamera					
				}			
			}else{
				if (group.player && group.player.inJeepCamera){
					thread coop_stopJeepCamera
				}
				local.cam waitthread game.replace::delete
				local.i = 0 								
				continue
			}
			
			//handle his camera view
			local.deltaAngles = group.player.viewangles - group.player.oldViewAngles
			local.cam.angles = $jeepseat.angles + local.deltaAngles			
		}
		waitframe
	}
}end

//---------------------------
goTanksGo:
//---------------------------
	local.tankSpeed = 90
	local.tankAcceleration = 90

	$tank1 modifydrive 20 100 256
	$tank2 modifydrive 14.5 100 256
	$tank3 modifydrive 14 100 256
	$jeep modifydrive  170 120 256
	
	//$tank2 thread DontHitGuyInFront $tank1
	//$tank3 thread DontHitGuyInFront $tank2
	//$jeep thread DontHitGuyInFront $tank3
	
	$tank2 thread Tank2KillAxis
	
	$tank3 thread Tank3KillAxis

	$tank1 waittill drive
	$tank1.stopped = 1
	//********************************************

	thread attackTanksWith $artillery1 $explosion1
	wait level.artillerywhistletime
	waitthread handleTank1Death
end

// self DontHitGuyInFront $tank2
DontHitGuyInFront local.guyinfront:
	local.dist = 1000
	while(self.stopped != 1)
	{
		local.dist = vector_length(self.origin - $(local.guyinfront).origin)
		//iprintln local.dist
		
		if(local.dist < 300)
		{
			if(self.speed > 1)
			{
			self.speed = self.speed - 0.5
			self modifydrive self.speed 100 256
			}
		}
		else if(local.dist > 1000)
		{
			if(self.speed < 20)
			{
			self.speed = self.speed + 0.5
			self modifydrive self.speed 100 256
			}
		}
		waitframe
	}
End

ReplaceMg42guy:
	$firstmg42 thread global/mg42init.scr::AttachGuyToMG42 $mg42guy
	while(level.KillMg42Nest != 1)
	{
		if($mg42guy)
		{
			local.origin = $mg42guy.origin 
			//iprintln local.origin
			local.model = $mg42guy.model
			$mg42guy waittill death
			
		}
		else
		{
			local.origin = $($firstmg42.target).origin
			local.model = $($firstmg42.target).model
			//iprintln local.origin
			$($firstmg42.target) waittill death
		}
		if(level.KillMg42Nest == 1)
			End
			
		local.whatever = spawn local.model origin ( -6386 -5177 773)
		$firstmg42.target = local.whatever
		local.whatever exec global/disable_ai.scr
		local.whatever runto local.origin
		local.dist = 1000
		while(local.dist > 30)
		{
			local.dist = vector_length (local.whatever.origin - local.origin)
			//iprintln local.dist 
			waitframe
		}
		//iprintln "NOW WE WOULD BE DONE"
		$mg42guy delete
		wait 0.4
		local.whatever exec global/enable_ai.scr
		
		local.whatever.mg = $firstmg42
		local.whatever type_idle machinegunner
		local.whatever thread global/mg42init.scr::gunner_think
		//$mg42 thread global/mg42init.scr::AttachGuyToMG42	local.whatever
		local.whatever attackplayer
		wait 2.0
		local.whatever targetname "mg42guy"
			
	}
End

StopKillingParade:
	local.findname = $tankshootmg42 //waitthread global/FindTrigger.scr::FindTrigger "tankshootmg42"
	local.findname waittill trigger
	//iprintlnbold "StopKilling Parade"
	level.KillMg42Nest = 1
	local.mg42 =  waitthread global/FindTrigger.scr::FindTrigger "mg42exploder"

	$tank2.aimingAtSomething = 1
	wait .3
	$tank2.gun setAimTarget local.mg42
	$tank2.gun waittill ontarget
	$tank2.gun anim fire
	trigger local.mg42
		
	$($firstmg42.target) targetname "mg42guy"

	thread Earthquake $firstmg42.origin 1000
	thread MortarEmitter $firstmg42.origin models/emitters/mortar_dirt.tik
	thread pocketFlashFx models/fx/fx_pocketflash.tik $firstmg42.origin
	if($mg42guy)
		$mg42guy exec global/bullethit.scr (0 0 250) 5000 0 1
	if ($firstmg42.target != NIL && $firstmg42.target != NULL)
		$($firstmg42.target) exec global/bullethit.scr (0 0 250) 5000 0 1

	$mg42bipod delete
	$firstmg42 delete
	$tank2.gun anim idle
	$tank2.gun.aimingAtSomething = 0
End

spawnmg42guy:
/*
	println "spawned mg42guy"

	local.ent = spawn $mg42spawner.mdl
	local.ent.origin = $mg42spawner.origin
	local.ent forceactivate
	local.ent.creator = $mg42spawner
	local.ent thread global/ai.scr::spawncheck
	wait 0.5 // shouldn't need wait
*/
		
	local.ent = $mg42guy
	$mg42guy exec global/disable_ai.scr
//	$mg42 exec global/mg42.scr $mg42target $mg42path $endarea $mg42temptrigger local.ent
	$mg42target thread turret_target $mg42path
	$mg42 setaimtarget $mg42target
	$mg42 tracerFrequency 3
	$mg42 firedelay 0.1
//	$mg42 burstFireSettings 0 10 1 1
	$mg42 startFiring
	wait 0.5

	while (isalive $mg42guy)
	{
//		$mg42 burstFireSettings 0 8 1 2

		$mg42 startfiring
		wait 1
	}
end

Tank2KillAxis:
	wait 3.0
	self waitthread TanksKill $tank1guys
	wait 8.0
	self waitthread TanksKill $tank1guys2 5000
End

Tank3KillAxis:
	wait 2.0
	self waitthread TanksKill $tank3guys
	wait 2.0
	self waitthread TanksKill $tank1guys3

	$towerguy attackplayer

	wait 4.0

	self.aimingAtSomething = 1
	wait .3
	self.gun setAimTarget $towerguy
	self.gun waittill ontarget
	self.gun anim fire
	local.trigger2 = waitthread global/FindTrigger.scr::FindTrigger "towerexplodertrigger"
	local.trigger2 triggerable
	trigger local.trigger2	
	$towerguy playsound explode_tower
	$firsttowerfloor remove
	$towerguy exec global/bullethit.scr (0 0 250) 5000 0 1
	self.aimingAtSomething = 0
	
	//iprintln "After loop"
	$mg42guy ai_on
	self.gun setAimTarget $tank1
	self.gun waittill ontarget
	self.gun setAimTarget NULL
	//self modifydrive 200 100 256
	self.gun anim idle
End

// Self is the tank doing the killing, and local.guy is guys doin' the dying
TanksKill local.guy local.distance local.stop:
	if(local.distance == NIL)
		local.distance = 800
	if(local.stop == NIL)
		local.stop = 0
//	iprintln ("Tank killing " + local.guy[1].targetname)
	for(local.i = 1; local.i <= local.guy.size; local.i++)
		{
			local.dist = 500
			while( (isalive local.guy[local.i]) && local.dist < local.distance)
			{
				if(self.stopshooting == 1)
				{
					self.gun anim idle
					End
				}
				local.dist = vector_length(self.origin - local.guy[local.i].origin)
				self.aimingAtSomething = 1
				wait .3
				self.gun setAimTarget local.guy[local.i]
				self.gun waittill ontarget
				wait 1.0
				self.gun anim fire	
				waitframe
				self.aimingAtSomething = 0
			}
		}
	self.gun anim idle
End

//----------------------------------------------
someoneShootAtTheTank:
//----------------------------------------------
//	iprintln "DEBUG: Im lookin!"
	self.lookingForTank = 1
	while (self && isAlive self)
	{
		local.view = self.origin + (0 0 75)
		local.tank = $tank3.origin + (0 0 150)
		local.cansee = sighttrace local.view local.tank
		if (local.cansee == 1)
		{
//			local.xcoord = randomint 600 - 299
//			local.ycoord = randomint 600 - 299
//			local.aimpoint = $tank2.origin + (local.xcoord local.ycoord 0)
//			iprintln "DEBUG: I see the tank!"
			self exec global/disable_ai.scr
			self exec global/aimat.scr $tank3
			self setaimtarget $tank3
			self exec global/shoot.scr
		}
		wait 2
	}
end

TanksKillParade local.guy local.distance local.stop:
	if(local.distance == NIL)
		local.distance = 800
	if(local.stop == NIL)
		local.stop = 0
//	println ("Tank killing " + local.guy[1].targetname)
	while(level.KillMg42Nest != 1){
		//chrissstrahl - fix error upon missing entity
		if(local.guy.size < 1){ end }
	
			local.dist = 500
			while( local.guy[1] && (isalive local.guy[1]) && self.pause != 1){
					self.aimingAtSomething = 1
					wait .3		 
					self.gun setAimTarget local.guy[1]
					self.gun waittill ontarget
					self.gun anim idle
					wait 3.0
					self.gun anim fire	
					waitframe
					self.aimingAtSomething = 0
				}
			wait 1.0
		self.gun anim idle	
	}
end

//---------------------------
runAway:
//---------------------------
	thread artilleryDialogue

	//*************
	thread tank3Run
	thread tank4Run
	//*************

	//********************************************
	thread attackTanksWith $artillery1 $explosion4
	//********************************************
	
	//********************************************
	thread attackTanksWith $artillery2 $explosion5
	//********************************************

	wait 3.0 //after stopping, pause before letting player out of tank

	$tank3 thread TanksKillParade $parade1spawner_paradeguy 5000 level.KillMg42Nest
	thread StopKillingParade
end

//---------------------------
tank3Run:
//---------------------------
	wait 2.0 //stagger the backup
	$tank3 drive $tank3backup -30 40 256 256
	$tank3 waittill drive
	$tank3 fullstop

end
//---------------------------

tank4Run:
//---------------------------
	$tank2 drive $tank2backup -10 20 256 256
	$tank2 waittill drive
	$tank2 fullstop
	waitframe
	// kill the roll so that our collision is happy
	local.angles = $tank2.angles
	local.angles[2] = 0
	$tank2.angles = local.angles
end


//---------------------------
playerExitTank:
//---------------------------

	thread coop_stopJeepSpawnManager //[202][hotfix] Smithy

	local.hackedOffset = (0 -100 0)
	local.driveEnterPos = $jeep gettagposition "driver_enter"	
	local.exitpos = local.driveEnterPos + local.hackedOffset
	
	//chrissstrahl - keep for singleplayer
	if(level.gametype == 0){
		local.startpos = $player.origin
	}

	//chrissstrahl - handle mp/sp
	if(level.gametype != 0){
		//chrissstrahl - update spawn location
		waitthread coop_mod/spawnlocations.scr::e1l2_update1
		//local.player = waitexec coop_mod/replace.scr::player_closestTo $jeep NIL
		//exec coop_mod/bt_playerTank.scr::playerExitTank local.player local.exitpos $jeep
		
		//chrissstrahl - debug test, do not run this code during debug
		if( level.coop_debugLevel == NIL ){
			level.coop_playerGlue = 0
			waitexec coop_mod/replace.scr::unglue
			waitexec coop_mod/main.scr::playersWarpto NIL NIL NIL //warps players to their spawn
			exec coop_mod/replace.scr::show	
		}

		thread coop_mod/replace.scr::givePlayerWeapon "weapons/US_W_MineDetector.tik" 	//[200] Smithy - we can do this now
		thread coop_mod/replace.scr::ammo "landmine" 4
		thread coop_mod/replace.scr::ammo "landmine" -4
	}else{
		$player unglue
		$player notsolid
		$player nodamage
		$player.origin = local.exitpos
		$jeep notsolid
		local.playerspot = spawn script_origin origin local.startpos
		$player glue local.playerspot 0
		local.playerspot time 0.2
		local.playerspot moveto local.exitpos
		local.playerspot move
	//give player mine detector
		$player item weapons/US_W_MineDetector.tik
		$player ammo landmine -4
		iprintlnbold (loc_convert_string ("You have acquired a mine detector"))
		wait 0.2
		$player unglue
		$player solid
		$jeep solid
		$player takedamage
		$player physics_on
	}

	thread IfPlayerRetreatEndMission	
	//thread global/MaintainCamera.scr::StopMaintainCamera
end

//---------------------------
artilleryDialogue:
//---------------------------
	$commander waitthread global/LoopAnim.scr::LoopAnimStop
	$commander anim A_12_FuchesTalk03 //"Artillery!  Pull back!"
	$commander waittill animdone
//	iprintln "(NewLine) Fuches:  Artillery!  Pull back!"
	$commander thread global/LoopAnim.scr::LoopAnim A_12_Fuches_idle
End

//---------------------------
introDialogue:
//---------------------------
	wait 20

	$commander waitthread global/LoopAnim.scr::LoopAnimStop
	$commander anim A_12_FuchesTalk01 //"We've got Jerry on the run, but he's dropping mines like crazy"
	$commander waittill animdone
	$commander anim A_12_FuchesTalk02 //"If we slow our pursuit to minesweep, their artillery will chew us up"
	$commander waittill animdone
	$commander waitthread global/LoopAnim.scr::LoopAnim A_12_Fuches_idle
end


///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
//                                   MISC STUFF                                          //
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------
attackTanksWith local.artilleryName local.explosionOrigin:{
//--------------------------------------------------------
	$(local.artilleryName).turret anim fakefire 
	local.explosionOrigin playsound arty_leadin05

	wait level.artillerywhistletime
//	local.explosionOrigin waittill sounddone
//	local.time = randomint(3) + 1

//	wait local.time

	local.explosionOrigin playsound flakk88_hit1
	
	//$player playsound flakk88_hit1
	//$player waittill sounddone
	//*******************************************************
	thread maps/e1l1/explosion.scr::big local.explosionOrigin
	//*******************************************************
}end

//---------------------------
startPinBackTanks:
//---------------------------
	while (level.pinBackTanks == 1)
	{
		local.pauseBetweenExplosionSets = 0
		while (local.pauseBetweenExplosionSets < 2)
		{
			local.pauseBetweenExplosionSets = randomfloat 5
		}

		local.pauseBetweenExplosions = randomfloat 3

		local.randSize = $randomexplode.size 
		local.i = randomint (local.randSize) + 1
		local.j = local.i

		while (local.j == local.i)
		{
			local.j = randomint $randomexplode.size	
			local.j += 1
			waitframe
		}

		if ($artillery1 != NIL || $artillery1 != NULL)
		{
			//********************************************************
			thread attackTanksWith $artillery1 $randomexplode[local.i]
			//********************************************************
		}

		wait local.pauseBetweenExplosions

		if ($artillery2 != NIL || $artillery2 != NULL)
		{
			//********************************************************
			thread attackTanksWith $artillery2 $randomexplode[local.j]
			//********************************************************
		}

		wait local.pauseBetweenExplosionSets
	}
end

//---------------------------
handleTank1Death:
//---------------------------	
	//***************************************************************
//	$tank1 drive $tank1backup 60 60 256 256
	//***************************************************************

//	$tank1 waittill drive
	$tank1 disconnect_paths
	$tank1.mineclearing detach
	$tank1.mineclearing remove

	//****************************************
	$tank1 thread global/autotank.scr::KillMe vehicles/US_V_MineClearingdes.tik
	//****************************************

	wait 0.5
	$tank1 notsolid
	local.collision = spawn script_object model $tank2.collide.brushmodel
	local.collision.origin = $tank1.origin
	local.collision.angles = $tank1.angles
	local.collision safesolid

	wait 0.5 //stagger the stop reaction 
	$tank2 fullstop
	$tank2.stopped = 1
	wait 0.3 //stagger the stop reaction 
	$tank3 fullstop
	$tank3.stopped = 1
	wait 0.1 //stagger the stop reaction 
	$jeep fullstop
	$jeep.stopped = 1
end


//-------------------------------------
turn2me:{
//-------------------------------------
	if (self != NIL && self != NULL){
		//self turnto $player //chrissstrahl
		self exec coop_mod/replace.scr::turnto //chrissstrahl - coop compatible
		self waittill turndone
		self turnto NULL
	}
}end

//---------------------------
CleanupIntro:
//---------------------------
$deletetrigger1 waittill trigger
	thread global/EntityCleanup.scr::EntityCleanup "mg42guy" 1000
	thread global/EntityCleanup.scr::EntityCleanup "parade1spawner_paradeguy" 1000
	thread global/EntityCleanup.scr::EntityCleanup "tank1guys3" 1000
	thread global/EntityCleanup.scr::EntityCleanup "tank1guys" 1000
	thread global/EntityCleanup.scr::EntityCleanup "tank1guys2" 1000
	thread global/EntityCleanup.scr::EntityCleanup "tank3guys" 1000
	thread global/EntityCleanup.scr::EntityCleanup "ambushguys" 1000

end


// --------------------------------------------------------
// camera shake prooporitional to distance of local.origin
// Default for maxShakeDist is 600 
// --------------------------------------------------------
Earthquake local.origin local.maxShakeDist:{
	if (!local.maxShakeDist){
		local.maxShakeDist = 600
	}

	//chrissstrahl - i decided tha we do only keep a single earthquake, not a own for each player, because it would be to much shaking
	//chrissstrahl - coop
	local.player = exec coop_mod/replace.scr::player_closestTo NIL local.origin
	while(local.player == NULL){
		local.player = exec coop_mod/replace.scr::player_closestTo NIL local.origin
		wait 1
	}
	
	local.dir = local.player.origin //chrissstrahl - coop
	local.dir -= local.origin
	local.dist = vector_length local.dir
	
	if (local.dist < local.maxShakeDist){
		local.t = local.dist/local.maxShakeDist
		local.mag = (2*local.t) + (6*(1.0 - local.t))
		earthquake 0.5 local.mag 1 0
	}
}end

// --------------------------------------------------------
// there are multiple options for mortar emitters
// --------------------------------------------------------
MortarEmitter local.origin local.emitter:

	local.ent = spawn local.emitter // "models/emitters/mortar_dirt_dustcloud.tik"

	local.ent.origin = local.origin
	local.ent anim idle
	local.ent notsolid
	wait 4
	local.ent anim stop
	local.ent delete

end

// --------------------------------------------------------
// --------------------------------------------------------
pocketFlashFx local.fx local.origin:
	
	local.temp = spawn script_model model local.fx
	local.temp notsolid
	local.temp.origin = local.origin  
	local.temp anim start
	local.temp notsolid
	waitframe
	local.temp remove
end

aimAtNothingYou:
	while (self && isAlive self)
	{
		if (self.aimingAtSomething == 0)
		{
			local.hackTarget = spawn script_origin
		
			local.vector = angles_toforward self.angles
			local.vector = vector_scale local.vector 2500
			local.hackTarget.origin = $tank2.origin + local.vector
			self.gun SetAimTarget local.hackTarget
			waitframe
			local.hackTarget delete
		}
		waitframe
	}
end

jeepGo:
	$jeep_passenger waitthread global/LoopAnim.scr::LoopAnimStop
	$jeep_passenger thread global/LoopAnim.scr::LoopAnim A_22_driving_idle
	$jeep anim start_wheels
end

jeepStop:
	$jeep_passenger waitthread global/LoopAnim.scr::LoopAnimStop
	$jeep_passenger thread global/LoopAnim.scr::LoopAnim A_31_GetIn_jeepidle
	$jeep anim stop_wheels
end


