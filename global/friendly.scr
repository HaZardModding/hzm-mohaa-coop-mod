//[202] chrissstrahl ///////////////////////////////////////
//Everytime I have to work on ai I have to read all the shitt again
//my solution is this list. Search for @<name-here> to go to the thinkstate of this ai type
//
// @stationary		-1)		AI that stays at the current position	
// @follow+lead		0)		AI follows/leads the player at an offset from his current position
// @followplayer	1)		AI follows the player at a distance
// @leadplayer		4)		AI Leads Player (the SAS Agent)
// @medic			5)		AI Medic follows and heals team and player
// @unknown			2,6,8)	OtherAI States 
// @heal					This is where the healing magic happens
////////////////////////////////////////////////////////////


//	Friendly system created by Mackey McCandlish.
//	
//	Before level waittill spawn "exec global/friendly.scr".
//	
//	To setup a friendly give a (preferrably American) AI targetname "friendly".
//	
//	You can set his #fnum to be 1 through 10. In the scripting system you can access him as level.friendly# (# being whatever 
//	fnum you set).
//	
//	You can make a friendly stop avoiding the player by setting his .avoidplayer to 0. You can turn it back on by setting
//	his .avoidplayer to 1.
//	
//	When you want to turn on the friendly AI, do "level.friendly# thread global/friendly.scr::friendlythink".
//	Afterwards you can set his friendtype like this: level.friendly#.friendtype = 1.
//	
//	The default friendtype is 0. Friendtypes actually used in MOH are:
//	
//	0	Offset Behavior:
//
//			The AI follows/leads the player at an offset from his current position (used in m1l1, m4l0, m5l1a, and m5l1b).
//
//		Give the nodes you want the friendlies to potentially stop at a targetname of "friendlynode".
//
//		Give the nodes a #set value ranging from 10 up to however high you go. You start with 10 at the beginning of the level
//		and then go up by 10s as you go through the level. So a "friendlynode" at the beginning of the level would be #set 10
//		and a node at the end of the level might have #set 600, whereas a node in the middle (in this case) would be roughly
//		#set 300. Multiple nodes can have the same #set value and you can use finer values like 15 or 11 or whatnot where you
//		need to.
//		
//		It helps to use $targetname instead of targetname so that the targetname is not changed every time you copy and paste 
//		a node. To further differentiate the nodes, press K and change their editor color for the 3d view.
//
//		You can also give groups of nodes a identical #area value (like #area 1 for example). When the AI feels like going to
//		a node with a .area of a given value, he will not go to any node that doesn't have that .area value until all the
//		enemies with targetname "enemy" and the same #area value (including enemies from enemyspawners that have the same #area
//		value) are dead. Then he will turn off those nodes forever and the AI will not try to go back to those nodes. Such
//		nodes obviously must be placed in the same general area, like in a singular building, so the AI can run in and clear
//		out the building then run out.
//
//		To determine where a friendly will follow in relation to the player, set his .mins and .maxs. For example to make a
//		friendly lead the player, like in m1l1, set his .mins to 20 and .maxs to 40. To make a friendly follow the player, like
//		m5l1a and m5l1b, set the mins to -40 and maxs to -20. Don't set the mins higher than the maxs.
//
//		You can further tweak the friendly with .distance and .waittime (they determine how close he has to get to nodes before
//		he goes for his next node and how long he waits at each node before following the player).
//
//
//	1	Barney Behavior (ahem).
//	
//			The AI follows the player at a distance (used in the majority of levels with friendlies aside from m1l1, m5l1a, 
//			and m5l1b). By default he'll follow the player, but you can make him follow other friendlies by setting his
//			.destination to be the friendly of choice.
//
//		You can alter how close the friendly follows with .distance and how long he waits with .waittime.
//
//	4	Leader Behavior.
//
//		Leader Behavior is very special case and was created exclusively for m1l2a (the SAS Agent). Basically he uses the same
//		friendlynode/#set system as Offset Behavior friendlies, but he stays slightly ahead of the player and fills in the nodes
//		one by one as he moves through the map (filling them in sequentially). Therefore nodes can not have the same #set and
//		there is no .mins or .maxs.
//
//		Friendlynodes for Leader Behavior can have a #flag value as well, like #flag 0. When the friendly gets to that node, he
//		will enable friendly avoid and then execute a thread called "flagthread0" in the current level.script. 
//
//		Anybody trying to setup such a friendly would have to spend a lot of time getting to know m1l2a.scr.
//
//	5	Medic Behavior.
//		
//			The AI follows the player and friendlies around like a Barney guy (with preference for friendlies over the player)
//			and will heal them if they're wounded sufficiently. He'll also heal himself a few times (limited). Occurs in m5l1b
//			and m4l0.
//
//		You don't have to do anything special with medics, but its nice to make sure they have a medic model. You can set their
//		.distance to control how close they follow.
//
//              Added August 11, 2003 by JP
//              .medichealrate allows you to set how much healing the medic does each time he heals someone around him. not set by default, 
//                instead just uses 0.5 by default.
//                Changed specifically for e3l1 but will work on any level.
//                
//	All the other friendly types are unsupported and just didn't turn out to be needed in the game. You should use friendtype
//	-1 when you want an AI to not do any special friendly AI and then do a wait 1 after setting friendtype -1 to make sure it
//	is active before you issue and new commands.

//	06/14/2002 (jsl) - Added new function to stop friendly...
//			do level.friendly# thread global/friendly.scr::friendlystop
//
//

main:
	//[202] chrissstrahl
	if(level.gametype==0){ $player.entref = -1 }
	level.friendly_auto_arrange	= 1
	waitthread friendlygen
end

soondie:
	level waittill spawn
	wait 4
	while (isalive self)
	{
		self damage $world 15000 $world (0 0 0) (0 0 0) (0 0 0) 0 9 0 0
		wait 1
	}
end


debug:
	level.frienddebug = 1
end

//-----------------------------------------------------
friendlystop:
//
//	After you've called friendlythink, you can call this to 
//	get rid of the friendly behaviour...
//
//-----------------------------------------------------
	self.friendly_stopped	= 1
End


friendlythink:
	//chrissstrahl - handle for aa
	/* @smithy - check if that handle is still required, I don't think it is
	if(level.coop_aaMap == 1){
		thread friendlythinkstart
		local.thread = parm.previousthread
		self waittill death
		if (local.thread)
		local.thread delete
	}else{ ...bt code here }
	*/
	
//println("COOPDEBUG friendly.scr::friendlythink - start for "+self.targetname+" $"+self.entnum)
	
	if ( self.friendlythink_thread==NIL || self.friendlythink_thread==NULL )
	{
		self.friendlythink_thread = NULL
		self.friendlythinkstart_thread = NULL

		self.friendlythink_thread = local
		self.friendly_stopped = 0

		thread friendlythinkstart

		self.friendlythinkstart_thread = parm.previousthread
		
	
		self waittill death
		
//println("COOPDEBUG friendly.scr::friendlythink - died for "+self.targetname+" $"+self.entnum)

		if (self.friendlythinkstart_thread!=NULL)
		{
			self.friendlythinkstart_thread delete
		}

		self.friendlythink_thread = NULL
		self.friendlythinkstart_thread = NULL
	}
	else
	{
		if ( self.friendly_stopped==1 )
		{
			
//println("COOPDEBUG friendly.scr::friendlythink - friendly_stopped==1 for "+self.targetname+" $"+self.entnum)

			self.friendly_stopped = 0
			if ( self.friendtype<0 )
			{
				self.friendtype = 1
			}
		}
//		else
//		{
//			println "trying to friendlythink while already friendlythinking! name=" self.targetname
//		}
	}
end


forceactiveatime:
	while (isalive self)
	{
		self forceactivate
		wait 50
	}
end

friendlyhealth:
	while (isalive self)
	{
		local.health = self.health
		self waittill pain
		print3d (self.origin + (0 0 70)) 2 (local.health - self.health)
		local.health = self.health
	}
end

//@smithy - this part is new, please veryify it does not create issues with AA
healthcheck:
	while (isalive self)
	{
		/*
			if ($health)
			println ("health " + $health.size + " health_pickup " + self.health_pickup + " friendtype " + self.friendtype)
			else
			println "no health"
		*/
		
		if ((self.health_pickup == TRUE) && ($health))
		{
		if (self.friendly_stopped==0)
		{
		if ((self.thinkstate != "attack") && ((self.friendtype == 1) || (self.friendtype == 0)))
		{
			if (self.health / self.maxhealth < (self.health_amount * 0.01))
			{
//				if (self.fnum)
//					println ("1fnum is " + self.fnum + " and friendtype is " + self.friendtype)
//				else
//					println ("1no fnum and friendtype is " + self.friendtype)

				local.oldfriendtype = self.friendtype
				local.range = 1200
				local.ent = -1
				for (local.i=1;local.i<$health.size+1;local.i++)
				{
					local.newrange = vector_length (self.origin - $health[local.i].origin)
					if (local.newrange < local.range)
					{
						local.ent = local.i
						local.range = local.newrange
					}
				}

				if (local.ent != -1)
				{
					self.friendtype = -2
					if ($health[local.ent].target)
						local.walktarget = $($health[local.ent].target)
					else
						local.walktarget = $health[local.ent]

					local.healthitem = $health[local.ent]

					local.break = 0
					while (local.break == 0)
					{
						self.movedoneradius = 50
						self runto local.walktarget
						self waittill movedone

						if (parm.movefail == 1)
							local.healthitem.targetname = "health_cantreach"

						if ((parm.movefail == 1) || (self.friendtype != -2) || (local.healthitem == NULL) || (self.thinkstate == "attack"))
							local.break = 1
						else
						if (vector_length (self.origin - local.walktarget.origin) < 80)
							local.break = 2
					}

					if (local.break == 2)
					{
						local.org = self.origin
						local.horg = local.healthitem.origin
						if ((local.org[2] - 10 < local.horg[2]) && (local.org[2] + 20 > local.horg[2]))
							local.sit = TRUE
						else
							local.sit = FALSE

						if (local.sit == TRUE)
							self exec global/crouch.scr // was stand

						println ("Grabbed health, my origin " + self.origin + " health origin " + local.healthitem.origin)
						self turnto local.healthitem
						wait 0.5
						self upperanim pickup_obj
						wait 0.33
						if (local.healthitem != NULL)
						{
							local.healthitem delete
							if (local.healthitem.amount > 25 ) 
								self playsound med_kit
							else
								self playsound med_canteen
	
							self heal (local.healthitem.amount * 0.02)
							println ("Friendly got health " + local.healthitem.amount)
							wait 0.3
			
							if (local.sit == TRUE)
								self exec global/stand.scr // was stand
						}
					}
					if (self.fnum)
						println ("2fnum is " + self.fnum + " and friendtype is " + self.friendtype)
					else
						println ("2no fnum and friendtype is " + self.friendtype)
					println ("made friendtype be " + local.oldfriendtype)
					self.friendtype = local.oldfriendtype
					wait 2
				}
			}
		}
		}
		}
		wait 1
	}
end

//[203] chrissstrahl - formated this buggy func so we can do proper debugging
//=======================================================
friendlythinkstart:{
//=======================================================
	if (level.frienddebug == NIL)
	println (self + " did friendlythink")

//println("COOPDEBUG friendly.scr::friendlythinkstart - start for "+self.targetname+" $"+self.entnum)

		level.entref++
		self.entref = "friendly" + level.entref

		if (self.lookat_time == NIL)
			self.lookat_time = 1

		if (self.look == NIL)
			self.look = 1

		if (self.area == NIL)
			self.area = -1

		if (self.mins == NIL)
			self.mins = -20

		if (self.maxs == NIL)
			self.maxs = 20

		if (self.friendtype == NIL)
			self.friendtype = 0


		if (self.distance == NIL)
			self.distance = 250

		//[202] chrissstrahl - made coop compatible
		//put it here so we can accsess it further below again without doing the sp/mp check again
		//as far as I can tell, this is all in the same frame
		local.player = $player
		if(level.gametype!=0){
			local.player = level.coop_player	
		}
		
//println("COOPDEBUG friendly.scr::friendlythinkstart - player ["+local.player+"] for "+self.targetname+" $"+self.entnum)
		
		//[202] chrissstrahl - made coop compatible - $player -> local.player
		if ((self.destination == NIL) || !(self.destination))
		{	
			if (level.friendlynodes < 1){
//println("COOPDEBUG friendly.scr::friendlythinkstart - player ["+local.player+"] for "+self.targetname+" $"+self.entnum)
				self.destination = local.player
			}else{
				if (self.friendtype == 0)
				{
//println("COOPDEBUG friendly.scr::friendlythinkstart - friendtype == 0 for "+self.targetname+" $"+self.entnum)
					for (local.i=1;local.i<level.friendlynodes+1;local.i++)
					{
						if (level.friendlyused[local.i] == 0)
						{
							self.destination = level.friendlynode[local.i]
							level.friendlyused[local.i] = 1
							local.i = level.friendlynodes + 5
						}
					}
					//println("COOPDEBUG friendly.scr::friendlythinkstart - friendtype == 0 destination friendlynode for "+self.targetname+" $"+self.entnum)
				}
				else{
//println("COOPDEBUG friendly.scr::friendlythinkstart - friendtype == 0 destination player ["+local.player+"] for "+self.targetname+" $"+self.entnum)
					self.destination = local.player
				}
			}
		}

		if (getcvar(debug) == "1")
			println ("destination is " + self.destination + " and friendtype is " + self.friendtype)


		if (self.friendlyrepulsetest)
			thread friendlyrepulse

		if (self.destinationset == NIL)
			self.destinationset = 10

		if (self.destinationnum == NIL)
			self.destinationnum = 10

		if (self.maxhealth == NIL)
			self.maxhealth = self.health

		if (self.waittime == NIL)
			self.waittime = 0.2

		if (self.health_amount == NIL)
			self.health_amount = 90

		if (self.friendtype == 5)
		{
//println("COOPDEBUG friendly.scr::friendlythinkstart - friendtype == 5 for "+self.targetname+" $"+self.entnum)
			self gun "none"
			self exec global/disable_ai.scr

			if (self.lasthealed == NIL)
				self.lasthealed = level.time + 1

			if (self.playerhealed == NIL)
				self.playerhealed = level.time + 1

			self.mins = -15
			self.maxs = 5
		}

//		if (getcvar(debug) == "1")
//			thread friendlyhealth

		self.originaldestination = self.destination

//	self type_attack "cover"
//	self.health = 5000
//	self ammo_grenade 4

		//[202] chrissstrahl - made coop compatible - $player -> local.player
		self.lastdestination = local.player // was -1
		
		//println("COOPDEBUG friendly.scr::friendlythinkstart - friendtype == 0 lastdestination ["+self.lastdestination+"] for "+self.entnum+" $"+self.targetname)
		
		local.standtime = level.time
		local.runtime = level.time
		local.friendrange = 50
		local.stand = 0
		thread forceactiveatime

		local.lastplayerset = -1
	self.health_pickup = TRUE
	thread healthcheck
	while (isalive self){		
		//println("COOPDEBUG friendly.scr::friendlythinkstart - thinkstate["+self.thinkstate+"] type["+self.friendtype+"] for "+self.targetname)	

		if (self.thinkstate != "attack" ){
			waitframe
//stationary Behavior /////////////////////////////////////////////// @stationary
//stationary Behavior ///////////////////////////////////////////////		
//stationary Behavior ///////////////////////////////////////////////		
//stationary Behavior ///////////////////////////////////////////////
			if (self.friendtype == -1 || self.friendly_stopped==1){
				if (self.waittime == -1){
					waitframe
				}else{
					wait self.waittime
				}
			}
//unknown Behavior /////////////////////////////////////////////// @unknown
//unknown Behavior ///////////////////////////////////////////////		
//unknown Behavior ///////////////////////////////////////////////		
//unknown Behavior ///////////////////////////////////////////////
			else{
				if (self.friendtype == 2){
					for (local.i = level.playernodenum;local.i<level.friendlynodes+1;local.i++){
						if (level.friendlyused[local.i] == 0){
							self.olddestinationnum = self.destinationnum
							self.destination = level.friendlynode[local.i]
							self.destinationset = level.friendlynode[local.i].set
							self.destinationnum = local.i

							if (level.frienddebug == 1){
								//[202] chrissstrahl - made coop compatible
								local.player = $player
								if(level.gametype!=0){ local.player = level.coop_player }
								println ("best choice was " + (vector_length(local.player.origin - level.friendlynode[local.i].origin)) + " away from player")
							}

							local.i = level.friendlynodes + 5
						}
					}

					thread friendlyused self.destinationnum

					if (self.destination != self.lastdestination){
						self thread ailookrun
						self runto self.destination
						if (level.frienddebug == 1){ println (self + " is running to " + self.destinationnum) }
						wait 1
						if (level.friendlyused[self.olddestinationnum] == 1){ level.friendlyused[self.olddestinationnum] = 0 }
						self waittill movedone
					}
					self.lastdestination = self.destination
			}
//unknown Behavior /////////////////////////////////////////////// @unknown
//unknown Behavior ///////////////////////////////////////////////		
//unknown Behavior ///////////////////////////////////////////////		
//unknown Behavior ///////////////////////////////////////////////
				else{
					if (self.friendtype == 8){
						for (local.i = level.playernodenum;local.i<level.friendlynodes+1;local.i++){
							if ((level.friendlyused[local.i] == 0) && (level.friendlynode[local.i].set > self.destinationset)){
								self.olddestinationnum = self.destinationnum
								self.destination = level.friendlynode[local.i]
								self.destinationset = level.friendlynode[local.i].set
								self.destinationnum = local.i

								if (level.frienddebug == 1){
									//[202] chrissstrahl - made coop compatible
									local.player = $player
									if(level.gametype!=0){ local.player = level.coop_player }
									println ("best choice was " + (vector_length(local.player.origin - level.friendlynode[local.i].origin)) + " away from player")
								}

								local.i = level.friendlynodes + 5
							}
						}

						thread friendlyused self.destinationnum

						if (self.destination != self.lastdestination){
							self thread ailookrun
							self runto self.destination
							if (level.frienddebug == 1){ println (self + " is running to " + self.destinationnum) }
							wait 1
							if (level.friendlyused[self.olddestinationnum] == 1){ level.friendlyused[self.olddestinationnum] = 0 }
							self waittill movedone
						}

						self.lastdestination = self.destination
					}
//followplayer Behavior /////////////////////////////////////////////// @followplayer
//followplayer Behavior /////////////////////////////////////////////// //1 AI follows the player at a distance		
//followplayer Behavior ///////////////////////////////////////////////		
//followplayer Behavior ///////////////////////////////////////////////
						else{
							if (self.friendtype == 1){
								// auto-arrange the guys to have them follow each other...
								if ( level.friendly_auto_arrange==1 ){
									if (!(isalive self.destination) || !(self.destination) && self.beacon != "Player"){
									
										//[204]chrissstrahl - disabled this, because it spams in muliplayer
										if(level.gametype == 0){
											if !(isalive self.destination){ println ("1made destination player, destination was " + self.destination) }
											if !(self.destination){ println "3made destination player" }
										}

										//[202]chrissstrahl - coop compatibility
										//self.destination = $player
										//self.originaldestination = $player
										self waitthread coop_mod/main.scr::destination
										self.originaldestination = self.destination
									}

									self.destination = self.originaldestination

									for (local.i=1;local.i<level.friendlys+1;local.i++){
										if (isalive level.friendly[local.i]){
											if ((level.friendly[local.i].friendtype == 1) && (level.friendly[local.i].destination == self.destination) && (self != level.friendly[local.i])){
												if (((self.origin - self.destination.origin) * (self.origin - self.destination.origin)) >
												((level.friendly[local.i].origin - self.destination.origin) * (level.friendly[local.i].origin - self.destination.origin)))
												{
													self.destination = level.friendly[local.i]
												}
												else{
													level.friendly[local.i].destination = self 
												}
											}
										}
									}
								}

							local.movethread = -1
						
							//[202][hotfix] Smithy
							while ($player.size == 0){
								wait 2
							}
						
							//[202][hotfix] Smithy
							if (self.destination && self.beacon && self.destination.classname != "Player"){
								self.beacon = NIl
							}				

							//[202][hotfix] Smithy
							if (self.beacon == "Player"){					
								self.destination = level.coop_player
								self.tether = level.coop_player
								thread game.main::managePlayerToFollow
							}
						
						//[202] chrissstrahl - added check for self.destination
						if (self.destination && vector_length (self.destination.origin - self.origin) > self.distance + local.friendrange){
							self.movedoneradius = self.distance // + local.friendrange
							self runto self.destination // .origin
							local.stand = 0
							self waittill movedone
							
							if !(self.destination){
								//[202] chrissstrahl - coop compatible
								//self.destination = $player
								self.destination = level.coop_player
								println "2made destination player"
							}

							if (getcvar(debug) == "1"){ println "Ending the run" }
								
							//[202] chrissstrahl - fixed console spam if there is no player on the server but ai is already going (!self.destination)
							if (!self.destination || vector_length (self.destination.origin - self.origin) < self.distance + local.friendrange){
								self exec global/stand.scr
							}
						}
						else{
							if (local.stand == 0){
								self exec global/stand.scr
								local.stand = 1
							}
							wait self.waittime
						}
					}
//follow+lead Behavior /////////////////////////////////////////////// @follow+lead
//follow+lead Behavior ///////////////////////////////////////////////		
//follow+lead Behavior ///////////////////////////////////////////////		
//follow+lead Behavior ///////////////////////////////////////////////
						else{
							if (self.friendtype == 0){
								//println("COOPDEBUG friendly.scr::friendlythinkstart - friendtype==2 start type["+self.friendtype+"] for "+self.targetname)
								if (isalive self.destination){
									local.lastplayerset = level.playernodeset - 1;
									self.lastdestination = self.destination
									self.destinationset = 10
								}

								local.wanted_node = -1

								if (level.time > local.runtime){
									//println("COOPDEBUG friendly.scr::friendlythinkstart - level.time>local.runtime type["+self.friendtype+"] for "+self.targetname)
								
									local.entarray = -1
									local.entarrayentree = 0
									
									local.setnum = -1
									local.nodenum = -1

									if (self.area != -1){
										//println("COOPDEBUG friendly.scr::friendlythinkstart - self.area!=-1 type["+self.friendtype+"] for "+self.targetname)
										
										if (level.enemyarea[self.area] < 1){
											//println("COOPDEBUG friendly.scr::friendlythinkstart - level.enemyarea[self.area]<1 type["+self.friendtype+"] for "+self.targetname)
										
											if (level.friendlynode[self.destinationnum].area == self.area){ level.friendlyused[self.destinationnum] = -1 }

											self.area = -1
											if (getcvar(debug) == "1"){ println (self.entref + " is now at area " + self.area) }
										}else{											
											for (local.i=1;local.i<level.friendlynodes+1;local.i++){
												local.entnum = -1
												local.entset = -1

												if (level.friendlynode[local.i].area == self.area){
													if ((self.destinationset < level.friendlynode[local.i].set) && (level.friendlyused[local.i] == 0) && (self.lastdestination != level.friendlynode[local.i])){
														if (level.friendlynode[local.i].set > local.entset){
															local.entset = level.friendlynode[local.i].set
															local.entnum = local.i
															local.entarray = -1
															local.entarrayentree = -1
														}
													}
												}

												if (local.entnum != -1){
													local.wanted_node = local.entnum
													local.i = level.friendlynodes + 5
												}
												else{
													if (level.friendlynode[local.i].area == self.area){
														if (	(self.lastdestination != level.friendlynode[local.i]) &&
																(self.destinationset <= level.friendlynode[local.i].set) &&
																(level.friendlyused[local.i] == 0))
														{
															local.entarrayentree++
															if (local.entarray == -1){
																local.entarray = NIL
																local.entarrayentree = 1
															}
															local.entarray[local.entarrayentree] = local.i
														}
													}
												}
											}
										}
									}	
									else{
										if (local.lastplayerset != level.playernodeset){
											if (local.lastplayerset > level.playernodeset){
												local.direction = down
											}else{
												local.direction = up
											}

											local.lastplayerset = level.playernodeset
											
											for (local.i=1;local.i<level.friendlynodes+1;local.i++){
												if ((local.i != level.playernodenum) && (local.setnum < level.friendlynode[local.i].set) && ((level.friendlynode[local.i].set > level.playernodeset + self.mins) && (level.friendlynode[local.i].set < level.playernodeset + self.maxs) && (level.friendlyused[local.i] == 0)) && (self.lastdestination != level.friendlynode[local.i]) && (self.destinationset != level.friendlynode[local.i].set))
												{
													local.setnum = level.friendlynode[local.i].set
													local.nodenum = local.i
													local.wanted_node = local.nodenum
												}
											}

											if (local.nodenum == -1){
												local.set1 = -1
												for (local.i1=level.playernodenum+1;local.i1<level.friendlynodes+1;local.i1++){
													if (level.friendlyused[local.i1] == 0){
														local.set1 = local.i1
														local.i1 = level.friendlynodes + 5
													}
												}

												local.set2 = -1
												for (local.i2=level.playernodenum-1;local.i2>1;local.i2--){
													if (level.friendlyused[local.i2] == 0){
														local.set2 = local.i2
														local.i2 = -5
													}
												}

												if (local.set1 == -1){
													if (local.set2 != -1){ local.nodenum = local.set2 }
												}else{
													if (local.set2 == -1){
														local.nodenum = local.set1
													}else{
														local.preferred = (level.playernodeset + self.mins) * 0.5 + (level.playernodeset + self.maxs) * 0.5
														if (abs(local.preferred - level.friendlynode[local.set1].set) < abs(local.preferred - level.friendlynode[local.set2].set))
															local.nodenum = local.set1
														else
															local.nodenum = local.set2
													}
												}

												local.wanted_node = local.nodenum

												if (getcvar(debug) == "1"){
													if (local.nodenum == -1){
														println (self.entref + " failed to find an acceptable node")
													}else{
														println (self.entref + " is going to go for node with set " + level.friendlynode[local.wanted_node].set + " as a last resort")
													}
												}
											}else{ //chrissstrahl - nodenum NOT -1
												if (getcvar(debug) == "1")
													println (self.entref + " is at node with set " + self.destinationset + " and wants node with set " + level.friendlynode[local.wanted_node].set)

												if (	((local.direction == up) &&
														(level.friendlynode[local.nodenum].set < self.destinationset)) ||
														((local.direction == down) &&
														(level.friendlynode[local.nodenum].set > self.destinationset)))
												{
													local.nodenum = -1
													local.wanted_node = -1
												}
											}
										}
									}

									if (local.entarray != -1){
										local.num = (randomint (local.entarrayentree) + 1)
										local.i = local.entarray [local.num]

										local.wanted_node = local.i
									}

									if (local.wanted_node != -1){
										//if (level.friendlynode[self.destinationnum]){
											//if (level.friendlynode[self.destinationnum].set){
												//println (self.entref + " gave up node " + level.friendlynode[self.destinationnum].set)
											//}
										//}

										if (level.friendlyused[self.destinationnum] == 1){ level.friendlyused[self.destinationnum] = 0 }

										self.destinationnum = local.wanted_node
										//println (self.entref + " took node " + level.friendlynode[local.wanted_node].set)
										thread friendlyused self.destinationnum
										self.destination = level.friendlynode[local.wanted_node]
										self.destinationset = level.friendlynode[local.wanted_node].set

										if (level.friendlynode[local.wanted_node].area != -1){ self.area = level.friendlynode[local.wanted_node].area }

										self turnto NULL								
										self waitthread seekdestination local.friendrange local.runtime
										if (self.destination.thread){ self thread level.script::self.destination.thread }
									}


			//					local.stand = waitthread repulsar local.friendrange local.stand

									for (local.i=1;local.i<level.friendlys+1;local.i++){
										if (isalive level.friendly[local.i]){
											if (	(self.area == -1) &&
													(level.friendly[local.i].area != -1) &&
													(level.enemyarea[level.friendly[local.i].area] > 0) &&
													(level.friendly[local.i].friendtype == 0))
											{
												self.area = level.friendly[local.i].area
												if (self.fnum == NIL){ self.fnum = -2 }
											}
										}
									}
								}
							}
//LEAD PLAYER//////////////////////////////////////////////////// @leadplayer
//LEAD PLAYER//////////////////////////////////////////////////// m1l2a, Grillo, SAS Agent @smithy - this is where you will find the ai to tune for the agent
//LEAD PLAYER////////////////////////////////////////////////////
//LEAD PLAYER////////////////////////////////////////////////////
								else{
									if (self.friendtype == 4){
										//[202] chrissstrahl - taken from previouse version but not implemented
										//local.leadingAiPlayerMaxDistance = 200
										//if(level.gametype != 0){
										//	local.leadingAiPlayerMaxDistance = 500
										//}

										local.set = 5000
										local.nodenum = -1

										for (local.i=1;local.i<level.friendlynodes+1;local.i++){
											if ((level.friendlyused[local.i] == 0) && (level.friendlynode[local.i].set < local.set)){
												local.set = level.friendlynode[local.i].set
												local.nodenum = local.i
												if (getcvar(debug) == "1"){ println ("SAS wants to go to #SET " + local.set + " and nodenum " + local.nodenum) }
											}
										}

										if (local.nodenum == -1){ local.nodenum = self.destinationnum }
										else{ level.friendlyused[local.nodenum] = 1 }
								
										local.break = 0
										local.offset = 1 // was 10
										local.break = 0

										local.turntime = level.time + 2 + randomfloat (0.6)
										self.turndoneerror = 70

										while (local.break == 0){
											//[202] chrissstrahl - these where seperate, now the followup check is inside
											if (level.time > local.turntime){
												local.player = waitthread coop_mod/replace.scr::player_closestTo self
												self lookat local.player
												
												if (level.time > local.turntime + 1.2 + randomfloat (0.6)){
													self turnto local.player
													thread turntonull
													local.turntime = level.time + 9000
												}				
											}
				//							if (getcvar(debug) == "1")
				//								println ("nodenum is " + local.nodenum) // + " and the origin of friendlynode of such nodenum is " + level.friendlynode[local.nodenum].origin)

											// 200 was self.distance
											local.break = 1
									
											//[202] chrissstrahl - make sure there is a player
											local.player = waitthread coop_mod/replace.scr::player_closestTo self
											while(!(local.player)){
												self.flags["coop_followedPlayer"] = NIL //[203] chrissstrahl
												wait 2
												local.player = waitthread coop_mod/replace.scr::player_closestTo self
												
											}
											self.flags["coop_followedPlayer"] = local.player //[202][hotfix] Smithy - store the player being followed by or leading actor
									
											//[202] chrissstrahl - changed structure for performance - made coop compatible
											if (!(self exec coop_mod/replace.scr::cansee) && (local.set > level.playernodeset + local.offset) ){
												local.break = 0
											}else{
												//[205] chrissstrahl - fixed
												local.playerToSelfDistance = vector_length (self.origin - local.player.origin)
												if ((local.playerToSelfDistance > 200) && (level.friendlyused[local.nodenum] == 1) && (local.set > level.playernodeset + local.offset)){
													local.break = 0					
												}else if ((local.playerToSelfDistance > 200 ) && (local.set > level.playernodeset + local.offset) &&	!(exec coop_mod/replace.scr::sighttrace (0 0 0) level.friendlynode[local.nodenum].origin 1)){
													local.break = 0
												}
											}
									
											if (getcvar(sas) == "1"){
												println "------------------------"
												println ("Break was " + local.break)

												//[202] chrissstrahl - compatibility
												if (self exec coop_mod/replace.scr::cansee){ println "SAS could see the player" }
												else{ println "SAS could NOT see the player" }

												if (local.set > level.playernodeset + local.offset){
													println ("Friendlynode set " + local.set + " was greater than playernode set " + level.playernodeset + " + offset")
												}else{
													println ("Friendlynode set " + local.set + " was NOT greater than playernode set " + level.playernodeset + " + offset")
												}
										
												//[202] chrissstrahl - grab cloeset player
												local.player = waitthread coop_mod/replace.scr::player_closestTo self
												local.length = vector_length (self.origin - local.player.origin)
												if (local.length > 200){
													println ("Vector length " + local.length + " was greater than 200")
												}else{
													println ("Vector length " + local.length + " was NOT greater than 200")
												}
												
												//[202] chrissstrahl - compatibility
												//if ($player canseenoents (level.friendlynode[local.nodenum].origin + (0 0 50)))
												if (exec coop_mod/replace.scr::sighttrace (0 0 0) (level.friendlynode[local.nodenum].origin + (0 0 50)) 1){
													println ("Sight trace from player origin to SAS origin was true")
												}else{
													println ("Sight trace from player origin to SAS origin was false")
												}
												println "------------------------"
											}
											wait 0.1

											if (getcvar(hangin) == "1"){ println (self.entref + " is hangin out at 0 " + local.set) }

											if (level.friendlyused[local.nodenum] != 1){
												if (getcvar(debug) == "1"){
													println (self.entref + " broke out of " + local.set + " to move on")
												}

												local.break = 1
											}
										}

										if (level.friendlynode[self.destinationnum + 1]){
											self thread lookpastlow level.friendlynode[self.destinationnum + 1] 0.6
										}else{
											self thread lookpastlow self.destination 0.6
										}

				//						wait 0.4
				//						println ("****** Turning towards " + self.destination)
				//						self turnto self.destination
				//						thread turntonull
				//						wait 0.3

										local.tempnodenum = 0
								
										//[202] chrissstrahl - compatibility		
										if (!(self exec coop_mod/replace.scr::cansee) && (local.set > level.playernodeset + local.tempnodenum) ){
											local.break = 1
										}else{
											local.player = waitthread coop_mod/replace.scr::player_closestTo self
											local.length = vector_length (self.origin - local.player.origin)			
											if ((local.length > self.distance) &&  (level.friendlyused[local.nodenum] == 1) && (local.set > level.playernodeset + local.tempnodenum)){
												local.break = -1
											}
										}

										if (local.set < level.playernodeset + local.tempnodenum){ local.break = 1 }
									
										if (level.friendlyused[local.nodenum] == 1){
											if (local.nodenum != -1){
												self.destination = level.friendlynode[local.nodenum]
												self.destinationnum = local.nodenum
												self.destinationset = level.friendlynode[local.nodenum].set

				//								println (self + " is running to " + local.set + " which is " + vector_length (self.origin - self.destination.origin) + " distance away")
						
												if (getcvar(debug) == "1"){
													println (self + " ran to " + self.destination + " at " + self.destination.origin + " with set # " + self.destination.set + " and player has set " + level.playernodeset)
													println ("======================== local.set is " + local.set + " and playerset is " + level.playernodeset)
												}

												local.broke = 0
												self.distance = 350
												self.movedoneradius = 350

												while (local.broke == 0){
													self runto self.destination
				//									println ("set is " + self.destination.set)

													if (getcvar(debug) == "1"){
														println ("1 Friendly used is " + level.friendlyused[local.nodenum])
														println (self.entref + " may hang out at 1 " + local.set)
													}
													
													local.elapsedtime = level.time + 6
													
													self.checkmovedone = 0
													thread checkmovedone

													while ((self.checkmovedone == 0) && ( level.friendlyused[local.nodenum] == 1)){
														if (getcvar(hangin) == "1"){
															println (self.entref + " is hangin out at 1 " + local.set)
														}
														wait self.waittime
													}

													if (self.checkthread){ self.checkthread delete }

													if (self.destination.target){
														local.ent = self.destination.target

														while (local.ent.target){
															local.ent = local.ent.target
														}

														local.origin = local.ent.origin
													}else{
														local.origin = self.destination.origin
													}
													
													if (vector_length (self.origin - local.origin) < self.distance + 25){
														local.broke = 1
													}
													waitframe
												}

												if (getcvar(debug) == "1"){
													println ("2 Friendly used is " + level.friendlyused[local.nodenum])
												}

												if (level.friendlynode[local.nodenum].flag != NIL) {
													self.movedoneradius = 0					
													while (vector_length (self.origin - level.friendlynode[local.nodenum].origin) > 100){
														if (getcvar(hangin) == "1"){
															println (self.entref + " is hangin out at 4 " + local.set)
														}

														if (getcvar(debug) == "1"){
															println ("======================== local.set is " + local.set + " and playerset is " + level.playernodeset)
														}

														if (local.break == 1){ self runto self.destination }
														else{ self walkto self.destination }

														self waittill movedone
														waitframe

														if (getcvar(hangin) == "1"){
															println (self.entref + " is hangin out at 3 " + local.set)
														}

													}

													if (level.friendlynode[local.nodenum].flag != NIL){
														if (level.friendlyused[local.nodenum] == 1){
															self.avoidplayer = 1
															self thread level.script::("flagthread" + level.friendlynode[local.nodenum].flag)
															level.friendlynode[local.nodenum].flag = NIL
														}
														else{
															if (getcvar(debug) == "1")
															println ("Didn't run flagthread " + ("flagthread" + level.friendlynode[local.nodenum].flag))
														}
													}
												}
											}
										}
									}
//Medic Behavior /////////////////////////////////////////////// @medic		
//Medic Behavior ///////////////////////////////////////////////		
//Medic Behavior ///////////////////////////////////////////////		
//Medic Behavior ///////////////////////////////////////////////
										else{
											if (self.friendtype == 5){
												if (level.time > self.lasthealed){
													self.lasthealed = level.time + level.medictime
													waitthread heal $player
										
													for (local.i=1;local.i<level.friendlys+1;local.i++){
														if (level.friendly[local.i] != self){
															waitthread heal level.friendly[local.i]
														}
													}

													if ((self.health * 100) / self.maxhealth < 40){
														waitthread canteen
													}
												}

												if (isalive level.friendly3 && self!=level.friendly3 ){
													self.destination = level.friendly3
												}else{
													if (isalive level.friendly2 && self!=level.friendly2 ){
														self.destination = level.friendly2
													}else{
														if ( isalive level.friendly1 && self!=level.friendly1 ){
															self.destination = level.friendly1
														}else{
															self.destination = $player
														}
													}
												}

												self.distance = 150
												self.movedoneradius = self.distance - 25
												if (vector_length (self.destination.origin - self.origin) > self.distance + local.friendrange){
													self runto self.destination
													self waittill movedone
													self exec global/crouch.scr // was stand
												}

					//					local.stand = waitthread repulsar local.friendrange local.stand
										}
//unknown Behavior /////////////////////////////////////////////// @unknown
//unknown Behavior ///////////////////////////////////////////////		
//unknown Behavior ///////////////////////////////////////////////		
//unknown Behavior ///////////////////////////////////////////////
										else{
											if (self.friendtype == 6){

											if (level.friendlyused[self.destinationnum] == 1){
												level.friendlyused[self.destinationnum] = 0
											}

											local.run = 0
											
											if (vector_length (self.destination.origin - self.origin) < 100){
												self exec global/stand.scr
											}else{
												self runto self.destination.origin
												local.run = 1
											}

											while (vector_length (self.destination.origin - self.origin) > 100){
												if (getcvar(debug) == "1"){ println "running" }
												wait self.waittime
											}
											wait self.waittime
										}
//unknown Behavior /////////////////////////////////////////////// @unknown
//unknown Behavior ///////////////////////////////////////////////		
//unknown Behavior ///////////////////////////////////////////////		
//unknown Behavior ///////////////////////////////////////////////
										else{
											if (self.friendtype == 7){
												if (level.time > local.runtime){
													local.entarray = -1
													local.entarrayentree = 0
													
													local.setnum = -1
													local.nodenum = -1

													if (	(self.destinationset < level.playernodeset + self.mins) ||
															(self.destinationset > level.playernodeset + self.maxs))
													{
														for (local.i=1;local.i<level.friendlynodes+1;local.i++){
															if (	(level.friendlynode[local.i].set > self.destinationset) &&
																	(local.setnum < level.friendlynode[local.i].set) &&
																	((level.friendlynode[local.i].set > level.playernodeset + self.mins) &&
																	(level.friendlynode[local.i].set < level.playernodeset + self.maxs) &&
																	(level.friendlyused[local.i] == 0)) &&
																	(self.lastdestination != level.friendlynode[local.i]) &&
																	(self.destinationset != level.friendlynode[local.i].set))
															{
																local.setnum = level.friendlynode[local.i].set
																local.nodenum = local.i

																if (local.nodenum != -1){
																	if (level.friendlyused[self.destinationnum] == 1){
																		level.friendlyused[self.destinationnum] = 0
																	}

																	self.destinationnum = local.nodenum
																	thread friendlyused self.destinationnum
																	self.destination = level.friendlynode[local.nodenum]
																	self.destinationset = level.friendlynode[local.nodenum].set
														
																	if (level.friendlynode[local.nodenum].area != -1){
																		self.area = level.friendlynode[local.nodenum].area
																		if (getcvar(debug) == "1"){ println (self + " joined area " + self.area) }
																	}
																}
															}
														}
													}
													self waitthread seekdestination local.friendrange local.runtime
												}
											}
//unknown Behavior /////////////////////////////////////////////// @unknown
//unknown Behavior ///////////////////////////////////////////////		
//unknown Behavior ///////////////////////////////////////////////		
//unknown Behavior ///////////////////////////////////////////////
											else{
												if (self.friendtype == 9){
													self.friendtype = 0
												}
											}
										}						//END OF - else{ if (self.friendtype == 7)...
									}							//END OF - else{ if (self.friendtype == 6)...
								}								//END OF - else{ if (self.friendtype == 5)...
							}									//END OF - else{ if (self.friendtype == 4)...
						}										//END OF - else{ if (self.friendtype == 0)...
					}											//END OF - else{ if (self.friendtype == 1)...
				}												//END OF - else{ if (self.friendtype == 8)...								
			}													//END OF - else{ if (self.friendtype == 2)...
		}														//END OF - if (self.thinkstate != "attack" )...
		else{ //self.thinkstate == "attack"
			wait self.waittime
		}
	} //while (isalive self)

	if (self.destinationnum != NIL){
		if ((level.friendlyused[self.destinationnum] == 1) && (self.friendtype == 0)){
			level.friendlyused[self.destinationnum] = 0
		}
	}
}end

canteen:

	if (self.canteen == NIL)
		self.canteen = 0

	self.canteen++
//	while (self.thinkstate == "attack")
//		waitframe

	if (self.canteen < 3)
	{
		wait 1
		self lookat NULL
		self nodamage
		self upperanim pass_canteen_drink
		self waittill upperanimdone

		if (getcvar(debug) != "1")
		self takedamage
			self.health = self.maxhealth
	}

end


checkmovedone:
	if (self.checkthread)
		self.checkthread delete

	self.checkthread = local

	//println "started the wait"
	self waittill movedone
	//println "ended the wait"
	self.checkmovedone = 1


end


//@heal
//@heal
//@heal
heal local.ent:
	if (isalive local.ent)
	{
		//[202] chrissstrahl - assume this is a $player array in multiplayer and heal cloeset player
		if( level.gametype != 0 && local.ent.size > 1 ){
			//[202] chrissstrahl - heal cloeset player, regardless which player he was running to
			//upgraded to select only hurt players based on coop_mod/replace.scr::player_closestTo
			if(!local.ent || local.ent.classname == "Player" ){
				local.player = NULL
				local.ent = NULL
				local.currentDistance = 999999
				local.closestDistance = 999999
				for (local.i = 1;local.i <= $player.size;local.i++){
					local.player = $player[local.i]
					
					local.maxHealthData = local.ent.maxhealth
					if!(local.maxHealthData){ local.maxHealthData = local.ent.max_health }
					local.health = (local.ent.health * 100) / local.maxHealthData
				
					if(local.player.health > 0 && local.health < level.medicmin && local.player.dmteam != "spectator" && local.player.flags["coop_isActive"] == 1){
						local.currentDistance = vector_length( local.player.origin - self.origin )
						if( local.currentDistance < local.closestDistance ){
							local.ent = local.player
							local.closestDistance = local.currentDistance
						}
					}
				}
				//[202] chrissstrahl - make sure we exit here if there is no valid player on server
				if!(local.ent){
					end
				}
			}
		}
		else{
			//[202] chrissstrahl - make sure this works
			local.maxHealthData = local.ent.maxhealth
			if!(local.maxHealthData){
				local.maxHealthData = local.ent.max_health
			}
			
			local.health = (local.ent.health * 100) / local.maxHealthData //[202] chrissstrahl		
		}

		if (local.health < level.medicmin)
		{
			self.no_idle = 0

			self.movedoneradius = 100
			self runto local.ent
			self waittill movedone

			self exec global/stand.scr
				
			if (isalive local.ent)
			{
				local.vec = vector_length (self.origin - local.ent.origin)
				if (local.vec < 140)
				{
					self nodamage
					self.avoidplayer = 0
//					self.no_idle = 1
					self turnto local.ent
					self lookat local.ent
					
					self waittill turndone
					self upperanim pass_canteen_start
					self waittill upperanimdone
					
					//[202] chrissstrahl - make sure the player is still valid
					if(isalive local.ent){
						//[202] chrissstrahl - fully heal in coop - or medic runs to several players and friendlies back and forth multiple times
						if(level.gametype != 0){
							local.ent heal 1
						}
						else{
							if(self.medichealrate == NIL || self.medichealrate == 0)
								local.ent heal 0.5
							else
								local.ent heal self.medichealrate								
						}
					}
					
					if(self.medichealrate == NIL || self.medichealrate == 0 || self.medichealrate > 0.5 )
						self playsound med_kit
					else
						self playsound med_canteen

					self upperanim pass_canteen_end
					self waittill upperanimdone

					self.avoidplayer = 1

					if (getcvar(alive) != "1")
						self takedamage
//					self.no_idle = 0


				}
			}
			if (getcvar(debug) == "1")
				println ("medic healed " + local.ent)
		}
	}
end


friendlyrepulse: 

	while (isalive self)
	{
		local.range = 40
		for (local.i=1;local.i<level.friendlys+1;local.i++)
		{
			if ((isalive level.friendly[local.i]) && (self != level.friendly[local.i]))
			{
				local.newrange = vector_length (self.origin - level.friendly[local.i].origin)
//println local.newrange
				if (local.newrange < local.range)
				{
					local.repulse = level.friendly[local.i]
					local.range = local.newrange
				}
			}
		}

		if (local.repulse)
		{
			local.ai_gap = 55
			local.avoidtime = level.time + 5.5 + randomfloat (1)
//			while ((vector_length (local.repulse.origin - self.origin) < 70) && (level.time < local.avoidtime))
//			{
//				local.ent = spawn script_origin "targetname" self.fnum
//				local.ent model animal/cockroach.tik
//				local.ent scale 100
				local.player_ai_delta = vector_normalize (self.origin - local.repulse.origin) * local.ai_gap
//				local.ent.origin = local.player_ai_delta + local.repulse.origin + ( 0 0 25 )
				local.origin = local.player_ai_delta + local.repulse.origin + ( 0 0 25 )
				self runto local.origin
//				wait 2
//				waitframe
//				local.ent remove
//			}	

	//		self thread ailookstand
//			if (vector_length (self.origin - local.repulse.origin) > 60)
//				self exec global/stand.scr
		}

		wait 3
	}

end



repulsar local.friendrange local.stand: 
	if (level.friendlyavoid == 1)
	{
		if (vector_length ($player.origin - self.origin) < self.distance - local.friendrange)
		{
			local.ai_gap = self.distance + local.friendrange
			while (vector_length ($player.origin - self.origin) < self.distance + local.friendrange)
			{

				local.ent = spawn script_origin
				local.player_ai_delta = vector_normalize (self.origin - $player.origin) * local.ai_gap
				local.ent.origin = local.player_ai_delta + $player.origin
				self runto local.ent.origin
				local.repulsetime = level.time + 2

				while ((vector_length ($player.origin - self.origin) > self.distance - local.friendrange) && (level.time < local.repulsetime))
					waitframe

				local.ent remove

				waitframe
			}
		}
		else
		if ((vector_length ($player.origin - self.origin) < self.distance + local.friendrange) && (local.stand == 0))
		{
			self thread ailookstand
			self exec global/stand.scr
			local.stand = 1

			if (getcvar(debug) == "1")
				println (self.entref + " stood at " + level.time)

			if (self.waittime == -1)
				waitframe
			else
				wait self.waittime
		}
	}

	if (self.destination != $player)	
	if (vector_length (self.destination.origin - self.origin) < self.distance - local.friendrange)
	{
		local.ai_gap = self.distance + local.friendrange
		while (vector_length (self.destination.origin - self.origin) < self.distance + local.friendrange)
		{

			local.ent = spawn script_origin
			local.player_ai_delta = vector_normalize (self.origin - self.destination.origin) * local.ai_gap
			local.ent.origin = local.player_ai_delta + self.destination.origin
			self runto local.ent.origin
			local.repulsetime = level.time + 2

			while ((vector_length (self.destination.origin - self.origin) > self.distance - local.friendrange) && (level.time < local.repulsetime))
				waitframe

			local.ent remove

			waitframe
		}
	}
	else
	if ((vector_length (self.destination.origin - self.origin) < self.distance + local.friendrange) && (local.stand == 0))
	{
		self thread ailookstand
		local.stand = 1
		self exec global/stand.scr

		if (self.waittime == -1)
			waitframe
		else
			wait self.waittime
	}

end local.stand		 

// huh
seekdestination local.friendrange local.runtime:

	if (getcvar(debug) == "1")
		println "1seeking destination"

	if ((vector_length(self.origin - self.destination.origin) > self.distance - local.friendrange) && (self.destination != NIL))
	{
		self thread ailookrun

		if (getcvar(debug) == "1"){
			if ((self.destination.area != NIL) && (self.destination.area != -1))
			{
				println (self.entref + " is trying to run to area " + self.destination.area + " with nodeset " + self.destinationnum + "/" + self.destinationset)
	//			println ("self destination's node/set is " + self.destination. 

			}
			println "2seeking destination"
		}
		
		self.movedoneradius = 90 // self.distance - local.friendrange
		
		if (getcvar(debug) == "1")
			println (self.entref + " is running to " + self.destinationset)
			
		self runto self.destination
		self waittill movedone
		
		if (getcvar(debug) == "1")
			println (self.entref + " arrived")
	
		self thread ailookrun

//		local.runtime = level.time + 2

//		while ((vector_length (self.origin - self.destination.origin) > self.distance - local.friendrange) && (level.playernodeset > self.destinationset + self.mins) && (level.playernodeset < self.destinationset + self.maxs))
//			wait self.waittime


//		self.lookthread delete
	}
	else
	{
		wait 1
		thread friendlyused self.destinationnum
	}

	self.lastdestination = self.destination

end

movedone:
	self.movedone = 0
	self waittill movedone
	self.movedone = parm.movedone
end


repulse:
	local.ai_gap = 150
	spawn script_origin targetname temp_scr_org
	local.player_ai_delta = vector_normalize (self.origin - self.destination.origin) * local.ai_gap
	$temp_scr_org.origin = local.player_ai_delta + self.destination.origin
	self runto $temp_scr_org.origin
	self waittill movedone
	$temp_scr_org remove
end







turntonull:
	thread turntonull1
	thread turntonull2
end

turntonull1:	
	self waittill turndone
	self turnto NULL
end

turntonull2:	
	wait 2
	self turnto NULL
end



ailookstand:

	if (self.lookthread != NIL)
		self.lookthread delete

	if (self.look == 0)
		end


//	self lookat level.friendly1 
//	end

	self.lookthread = local
//	self lookat self.destination
//	wait (randomfloat (3) + 2)

	while (isalive self)
	{	
//println "WTF"
		local.random = randomint(100)
		if (local.random > 50)
		{
			if (level.friendlynodes > 0)
			{
		
				if (level.friendlynode[self.destinationnum])
				local.look = level.friendlynode[self.destinationnum]
				else
				local.look = 1

				while (level.friendlynode[local.look] == self.destination)
				{
					local.look = level.playernodenum + randomint(10) - 5
					if (local.look < 1)
						local.look = 1

					if (local.look > level.friendlynodes)
						local.look = level.friendlynodes
				}
					
				if (vector_length (self.origin - level.friendlynode[local.look].origin) > 180)
				{
					self thread lookpastlow level.friendlynode[local.look]
					self.turndoneerror = 70
					self thread turn_null level.friendlynode[local.look]
				}
			}
			else
			{
				local.look = randomint(level.friendlys) + 1

				if (local.look < 1)
					local.look = 1

				if (local.look > level.friendlys)
					local.look = level.friendlys

				if (isalive level.friendly[local.look])
				{
					self lookat level.friendly[local.look]
					self.turndoneerror = 30
					self thread turn_null level.friendly[local.look]
				}
			}
		}
		else
		if (vector_length (self.origin - self.destination.origin) > 180)
		{
			self thread lookpastlow self.destination
			self.turndoneerror = 30
			self thread turn_null self.destination
		}

		wait (randomfloat (6) + 1.5)
	}
end

turn_null local.ent:
	self.turndoneerror = 70
	self turnto local.ent
	self waittill turndone
	self turnto NULL
end


ailookrun:

	if (self.lookthread != NIL)
		self.lookthread delete

	if (self.look == 0)
		end

	self.lookthread = local

	self lookat NULL

	local.wait_time = 0.5

	while (isalive self)
	{	
		if (level.time > self.lookat_time)
		{
			local.random = randomint(100)
			
			if ((level.friendlynodes > 0) && (local.random > 75))
			{
				local.look = level.playernodenum + randomint(4) + 4

				if (self.destination == level.friendlynode[local.look])
					local.look++

				if (local.look > level.friendlynodes)
					local.look = level.friendlynodes

				if (vector_length (self.origin - level.friendlynode[local.look].origin) < 200)
					local.look++

				if (local.look > level.friendlynodes)
					local.look = level.friendlynodes

				self thread lookpastlow level.friendlynode[local.look]
				local.wait_time = (randomfloat (3) + 1)
			}
			else if (local.random > 50)
			{
				local.ent = level.friendly[randomint(level.friendlys) + 1]

	//			if (sighttrace (self.origin + (0 0 35)) (local.ent.origin + (0 0 35)) 1)
				if ((isalive local.ent) && (self cansee local.ent 90))
				{
					self lookat local.ent
					local.wait_time = (randomfloat (1.5) + 0.5)
				}
				else
				{
					self lookat NULL
					local.wait_time = 0.5
				}
			}
			else if (local.random > 25)
			{
				//[203] chrissstrahl - coopified this
				self exec coop_mod/replace.scr::lookat
				local.wait_time = (randomfloat (1.5) + 0.5)
			}
			else
			{
				self lookat NULL
				local.wait_time = 0.5
			}

			self.lookat_time = level.time + local.wait_time 

			wait local.wait_time 
			self lookat NULL
			wait (1 + randomfloat(1))
		}
		else
			wait 1
	}
end



drawline:
	while (1)
	{
		if (getcvar(line) == "1")
		{
			for (local.i=1;local.i<level.friendlys+1;local.i++)
			if ((isalive level.friendly[local.i]) && (level.friendly[local.i].destination) && (level.friendly[local.i].destination.origin) && (level.friendly[local.i].thinkstate != "attack"))
				debugline level.friendly[local.i] level.friendly[local.i].destination.origin 0.2 0.8 0.65 0.5
		}
		else
		wait 2

		waitframe
		waitframe
	}
end


nodeprint:


	thread drawline
	local.p = 0
	local.z = 0

	// Don't forget, DISABLE FOR RELEASE

	local.timer = level.time
	while (1)
	{
		if (getcvar(debug) == "1")
		{
			local.p = local.z

			if (level.time > local.timer)
			{
				local.z++
				local.timer = level.time + 1
				if (local.z > 2)
					local.z = 0
			}

			for (local.i=1;local.i<level.friendlynodes+1;local.i++)
			{
				local.p++
				if (local.p == 3)
				{
					thread tempprint3d (level.friendlynode[local.i].origin + (0 0 35)) 2 level.friendlynode[local.i].set
					if (level.friendlynode[local.i].thread)
						thread tempprint3d (level.friendlynode[local.i].origin + (0 0 65)) 2 level.friendlynode[local.i].thread
					local.p = 0
				}
			}
			waitframe
		}
		else
		{
			wait 1
		}

	}

end

tempprint3d local.org local.sizer local.num:
	level waittill postthink
	print3d local.org local.sizer local.num
end

//@smithy @chrissstrahl
playernode:
	//[202] chrissstrahl - keep for sp
	if(level.gametype == 0){
		$player.fnum = -1 //fnum = friendly number - 1 to 12
	}
	
	if (level.usedrange == NIL)
		level.usedrange = 2


	level.playernodenum = 1
	level.playernodeset = 1
//println ("playernodeset is " + level.playernodeset)

	level waittill spawn
	thread nodeprint

//	level.playernodeset = level.friendlynode[level.playernodenum].set
//	println ("level playernodeset is " + level.playernodeset)
//	level.playernoderadius = 50000


	local.setnum = 0
	level.playernode = level.friendlynode[1]
	
	//[202] - chrissstrahl
//println("DEV: playernode 0-friendlyPlayerOrigin")
	local.fpo = (exec coop_mod/main.scr::friendlyPlayerOrigin)
	
	level.playernoderadius = vector_length (level.friendlynode[level.playernodenum].origin - local.fpo) //[202] - chrissstrahl

	local.num = level.playernodenum

	for (local.i=1;local.i<level.friendlys+1;local.i++)
		local.number[local.i] = level.friendly[local.i].area

	local.min = -10
	local.max = 10

	thread playernode_evaluate

	local.playerheld = -1
	while (1)
	{
		if (level.script == "maps/m1l2a.scr")
		{
//			println "held is -1"
			local.playerheld = -1
		}
	local.playerheld = -1

		if (local.playerheld != -1)
		{
			level.friendlyused[local.playerheld] = 0
			local.playerheld = -1
		}
		// debug stuff
		/*
		for (local.i=1;local.i<level.friendlys+1;local.i++)
		{
			if ((isalive level.friendly[local.i]) && (level.friendly[local.i].area != NIL))
			if (local.number[local.i] != level.friendly[local.i].area)
			{

					println "-**************************************-"
				for (local.p=1;local.p<level.friendlys+1;local.p++)
				{
					if ((isalive level.friendly[local.p]) && (level.friendly[local.p].area != NIL))
					{
						huddraw_font (local.i + 100) "facfont-20"
						huddraw_string (local.i + 100) level.friendly[local.p].area
						huddraw_align (local.i + 100) left top
						huddraw_rect (local.i + 100) 0 (80 + local.i*18) 0 0
						local.number[local.p] = level.friendly[local.p].area

//						println (level.friendly[local.p] + " is exploring area " + level.friendly[local.p].area)
					}
				}
					println "-**************************************-"
				local.i = level.friendlys + 5
			}
		}
		*/

		//[202] - chrissstrahl
//println("DEV: playernode 1-friendlyPlayerOrigin")
		local.fpo = (exec coop_mod/main.scr::friendlyPlayerOrigin)

		level.playernoderadius = vector_length (level.friendlynode[level.playernodenum].origin - local.fpo) //[202] chrissstrahl
//		level.playernoderadius = 50000
		local.p = 0
		local.newnum = -1
		local.lowset = level.playernodenum + local.min

		if (local.lowset < 1)
			local.lowset = 1

			local.highset = level.playernodenum + local.max

		if (local.highset > level.friendlynodes)
			local.highset = level.friendlynodes

		if (getcvar(playerset) == "1")
			println ("highset is " + local.highset + " with set " + level.friendlynode[local.highset].set)

		if (local.setnum != level.playernodenum)
		{
		if (getcvar(playerset) == "1")
				println ("lowest = " + local.lowset + " and highest = " + local.highset + " and playernum = " + level.playernodenum)

			local.setnum = level.playernodenum
		}

		for (local.i=local.lowset;local.i<local.highset+1;local.i++)
		if (level.friendlyused[local.i] < level.usedrange)
		{
			local.radius = vector_length (level.friendlynode[local.i].origin - local.fpo) //[202] chrissstrahl
			if (local.radius < level.playernoderadius + 1)
			{
				local.newnum = local.i
				if (getcvar(playerset) == "1")
				{
					println ("Local radius is " + local.radius + " and level.playernoderadius is " + level.playernoderadius)
					println ("The playernoderadius is " + level.playernoderadius + " and the node was " + level.playernodeset + " at distance " + vector_length (local.fpo - level.friendlynode[level.playernodenum].origin) + " but is now node with set " + level.friendlynode[local.newnum].set + " at distance of " + vector_length (local.fpo - level.friendlynode[local.newnum].origin)) //[202] chrissstrahl
				}
				level.playernoderadius = local.radius
			}
		}
		
		//[202] chrissstrahl - added pause here if there is no player on server
		//ai ain't gonna go anywhere anyway
		while!($player){
			wait 2
		}

		waitframe
	}

/*
	for (local.i=1;local.i<level.friendlynodes+1;local.i++)
	{
		if (level.time > level.friendlyusedtime[local.i])
		if (level.friendlyused[local.i] == 1)
		{
			if (getcvar(debug) == "1")
				print "C"

			level.friendlyused[local.i] = 0
			level.friendlyusedtime[local.i] = level.time + level.friendlyusedtimeupdate
		}
	}
*/
	
end

playernode_evaluate:

	level waittill spawn

	local.newnum = -1

	while( 1 )
	{
		if (getcvar(playerset) == "1")
			println ("node 1 " + local.newnum)

		if (level.playernoderadius > 300) // was 600
			local.newnum = -1


		if (local.newnum == -1)
		{
			local.radi = 50000
			local.lasti = 10
			for (local.i=1;local.i<level.friendlynodes+1;local.i++)
			if (level.friendlyused[local.i] < level.usedrange)
			{
				//[202] - chrissstrahl - this func is called unssearly often, reduce this
				local.fpo = (exec coop_mod/main.scr::friendlyPlayerOrigin)
				local.radius = vector_length (level.friendlynode[local.i].origin - local.fpo) //[202] chrissstrahl

				if (local.radius < local.radi)
				{
					local.radi = local.radius
					level.playernoderadius = local.radius
					local.newnum = local.i
				}
				// do lazy evaluation of this behemoth
				if ( local.i > local.lasti )
				{
					local.lasti += 10
					waitframe
				}
			}
		}

		if (getcvar(playerset) == "1")
			println ("node 2 " + local.newnum)
	
		if ((local.newnum != -1) && (level.friendlynode[local.newnum].set != -1))
		{
			if (local.playerheld != -1)
			if (level.friendlyused[local.newnum] == 0)
			{
				level.friendlyused[local.newnum] = 1
				local.playerheld = local.newnum
			}

			level.playernodenum = local.newnum
			level.playernodeset = level.friendlynode[local.newnum].set
			
			//[202] - chrissstrahl - this func is called unssearly often, reduce this
			local.fpo = (exec coop_mod/main.scr::friendlyPlayerOrigin)		
			level.playernoderadius = vector_length (level.friendlynode[level.playernodenum].origin - local.fpo)
		}

		if (getcvar(playerset) == "1")
			println ("node 3 " + local.newnum)

		if (getcvar(cnode) == "1")
			println ("Player's distance to his current node is " + level.playernoderadius + " and that node set is " + level.friendlynode[local.newnum].set + " and the node num is " + level.playernodenum)

//		if (local.num != level.playernodeset)
//		{
//			println level.playernodeset
			local.num = level.playernodeset
//		}
	waitframe
	}

end


friendlyinit:
	self.fnum = -3
	self.waittime = 0.2
	self.noticescale = 1
	self.area = -1
	self.mins = -20
	self.maxs = 20
	self.friendtype = 0
	self.distance = 250
	self.destination = $player //[202] chrissstrahl - issue here is that this is a script origin - don't ask
	self.destinationset = 10
	self.destinationnum = 10
end

friendlygen:

	level.playernodenum = -1
	level.playernodeset = -1

	level.friendlyavoid = 1

	if (level.entref == NIL)
		level.entref = 0

	//[202] chrissstrahl
	if(level.gametype == 0){
		$player.maxhealth = $player.health
	}
	
	level.deadent = spawn script_origin
	level.deadent thread friendlyinit

	level.medictime = 4 // was 2.5

	if (getcvar(skill) == "0")
		level.medicmin = 65
	else
	if (getcvar(skill) == "1")
		level.medicmin = 65
	else
	if (getcvar(skill) == "2")
		level.medicmin = 65



	if (level.frienddebug == NIL)
		level.frienddebug = 0

	level.friendlyusedtimeupdate = 5

	if ($friendly == NULL)
		level.friendlys = 0
		else
		level.friendlys = $friendly.size


	if (level.friendlys > 0)
	{
		level.friendly = exec global/makearray.scr $friendly

		for (local.i=1;local.i<level.friendlys+1;local.i++)
		{
			if (getcvar(debug) == "1")
				println ("friendly gen " + local.i)
	
			if (level.friendly[local.i].fnum == NIL)
				println ("Warning, friendly at origin " + level.friendly[local.i].origin + "has no #fnum") 1
				else
				println ("Spawned friendly " + level.friendly[local.i].fnum)

			

			
			level.friendly[local.i].noticescale = 1
			level.friendly[local.i].waittime = 0.2
			level.friendly[local.i].area = -1
			level.friendly[local.i].mins = -5
			level.friendly[local.i].maxs = 40
			level.friendly[local.i].friendtype = 0
			level.friendly[local.i].distance = 250
			level.friendly[local.i].destinationset = 10
			level.friendly[local.i].destinationnum = 10

			if (level.friendly[local.i].fnum)
				level.fnum[level.friendly[local.i].fnum] = level.friendly[local.i]
		
			if (level.friendly[local.i].fnum == 1)
				level.friendly1 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 2)
				level.friendly2 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 3)
				level.friendly3 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 4)
				level.friendly4 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 5)
				level.friendly5 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 6)
				level.friendly6 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 7)
				level.friendly7 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 8)
				level.friendly8 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 9)
				level.friendly9 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 10)
				level.friendly10 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 11)
				level.friendly11 = level.friendly[local.i] 

			if (level.friendly[local.i].fnum == 12)
				level.friendly12 = level.friendly[local.i] 

			level.friendly[local.i] thread friendlydeath
			
			if (getcvar(medic) == "1")
				level.friendly[local.i] thread soondie

		}
	}

	local.chaincount = 0
//	for (local.i=1;local.i<$friendlychain.size+1;local.i++)
	while ($friendlychain.size > 0)
	{

		local.ent =	$friendlychain[1]
//println ("friendlychains left " + $friendlychain.size + " current set " + local.chaincount)
		if (local.ent.set)
			local.ent.chain_set = local.ent.set
		else
			local.ent.chain_set = -1

		local.chain_set = local.ent.chain_set
		local.ent.set = local.chaincount
		local.ent.targetname = "friendlynode"
		local.breaker = 0
		while (local.breaker == 0)
		{
			if ((local.ent.target) && ($(local.ent.target)))
			{
				local.newent = local.ent.target
				local.chaincount+=10
				local.newent.set = local.chaincount
				local.newent.chain_set = local.chain_set
				local.ent.targetname = "friendlynode"
				local.ent = local.newent
			}
			else
			local.breaker = 1

		}
		local.chaincount+=500
	}


	if ($friendlynode == NULL)
		level.friendlynodes = 0
		else
		level.friendlynodes = $friendlynode.size

	if (level.friendlynodes > 0)
	{
		level.friendlynode = exec global/makearray.scr $friendlynode

		for (local.i=1;local.i<level.friendlynodes+1;local.i++)
		{
		
//if (level.friendlynode[local.i].setthread)
//	println ("friendlynode " + local.i + " has setthread " + level.friendlynode[local.i].setthread)
//else
//	println ("friendlynode " + local.i + " has no setthread ")

			level.friendlyused[local.i] = 0
			level.friendlyusedtime[local.i] = level.time + level.friendlyusedtimeupdate

			if (level.friendlynode[local.i].area == NIL)
				level.friendlynode[local.i].area = -1

			if (level.enemyarea[level.friendlynode[local.i].area] == NIL)
				level.enemyarea[level.friendlynode[local.i].area] = 0

			level.friendlynode[local.i].nodenum = local.i

			if (level.friendlynode[local.i].set == NIL)
			{
				println ("Warning, friendlynode at origin " + level.friendlynode[local.i].origin + "has no #set")
				level.friendlynode[local.i].set = -1
			}
		}

		println ("Spawned " + level.friendlynodes + " friendlynodes")

		for (local.i=1;local.i<level.friendlynodes+1;local.i++)
			local.used[local.i] = 0

		for (local.count=1;local.count<level.friendlynodes+1;local.count++)
		{
			local.num = 50000
			local.node = -1000

			for (local.i=1;local.i<level.friendlynodes+1;local.i++)
			{
				if ((level.friendlynode[local.i].set < local.num) && (local.used[local.i] == 0))
				{
					local.node = local.i
					local.num = level.friendlynode[local.i].set
				}
			}

			if (local.node == -1000)
				println ("ERROR No node found  __ " + local.count)

			level.friendlynodetemp[local.count] = level.friendlynode[local.node]
			local.used[local.node] = 1
		}

		for (local.i=1;local.i<level.friendlynodes+1;local.i++)
		{
			level.friendlynode[local.i] = level.friendlynodetemp[local.i]
			level.friendlynodetemp[local.i] = NIL
//println ("Set for friendlynode " + local.i + " is " + level.friendlynode[local.i].set)
		}

		if (getcvar(medic) != "1")
		thread playernode
		thread hudd
	}


	if ($enemy == NULL)
		level.enemys = 0
		else
		level.enemys = $enemy.size

//println ("There are " + level.enemys + " enemies")

	if (level.enemys > 0)
	{
		level.enemy = exec global/makearray.scr $enemy

		for (local.i=1;local.i<level.enemys+1;local.i++)
		{
//println ("Spawned enemy " + local.i)

			if (level.enemy[local.i].area == NIL)
				level.enemy[local.i].area = -1
			else
			{
				if (level.enemyarea[level.enemy[local.i].area] == NIL)
					level.enemyarea[level.enemy[local.i].area] = 0

					level.enemy[local.i] thread areatrigger 1
			}
				
			if (level.enemy[local.i].group == NIL)
				level.enemy[local.i].group = -1
			else
			{
				if (level.enemyset[level.enemy[local.i].group] == NIL)
					level.enemyset[level.enemy[local.i].group] = 0

					level.enemy[local.i] thread settrigger
			}
				
		}

	}

	//chrissstrahl - compatible to coop
	//level waittill spawn
	waitthread coop_mod/replace.scr::waitForPlayer
end

hudd:
	level waittill spawn

local.float = 0.5
local.base = 0.5



 
	local.timer = level.time - 1

	while (1)
	{

		if (getcvar(debug) == "1")
		{
			if (level.time > local.timer)
			{
				local.timer = level.time + 2
				for (local.i=1;local.i<level.friendlys+30;local.i++)
					huddraw_alpha (local.i + 100) 0

				for (local.i=1; local.i<level.friendlys+1;local.i++)
					if ((isalive level.friendly[local.i]) && (level.friendly[local.i].entref == NIL))
					{
						level.entref++
						level.friendly[local.i].entref = "friendly" + level.entref
					}

			}


			local.y = 210
			local.y = 160

			local.base += 0.11
			if (local.base > 1.5)
				local.base = local.base - 1

			local.add = 0

			for (local.i=1;local.i<level.friendlys+1;local.i++)
			{
				huddraw_alpha (local.i + 100) 0
				if ((isalive level.friendly[local.i]) && (level.friendly[local.i].entref != NIL))
				{
					local.add += 0.11
					local.float = local.base + local.add
					

					while (local.float > 1.0)
						local.float = local.float - 0.5

					local.y += 18
					huddraw_font (local.i + 100) "verdana-12"

					if (level.friendly[local.i].destination)
					{
						if (level.friendly[local.i].destination.entref)
							local.destname = ("F" + level.friendly[local.i].destination.entref)
						else
						if (level.friendly[local.i].destination.classname == "Player") //[202] chrissstrahl
							local.destname = "Player"
						else
							local.destname = level.friendly[local.i].destination.targetname
					}
						else
							local.destname = "None"

					if (level.friendly[local.i].area != -1)
						huddraw_string (local.i + 100) (level.friendly[local.i].entref + ":d" + local.destname + ":" + level.friendly[local.i].thinkstate + ":s" + level.friendly[local.i].destinationset + ":f" + level.friendly[local.i].friendtype + ":h" + level.friendly[local.i].health + ":a" + level.friendly[local.i].area + ":" + level.enemyarea[level.friendly[local.i].area])
					else
						huddraw_string (local.i + 100) (level.friendly[local.i].entref + ":d" + local.destname + ":" + level.friendly[local.i].thinkstate + ":s" + level.friendly[local.i].destinationset + ":f" + level.friendly[local.i].friendtype + ":h" + level.friendly[local.i].health)

					huddraw_align (local.i + 100) left top
					huddraw_rect (local.i + 100) 0 local.y 0 0
					huddraw_alpha (local.i + 100) local.float
				}
			}

			if ((level.currentfriendlies != NIL) && (level.maxfriendlies != NIL))
			{
				local.p = 98
				local.y += 18

						huddraw_font (local.p + 100) "verdana-12"

						local.string = ((level.currentfriendlies) + "/" + (level.maxfriendlies))
						huddraw_string (local.p + 100) local.string

						huddraw_align (local.p + 100) left top
						huddraw_rect (local.p + 100) 0 local.y 0 0
						huddraw_alpha (local.p + 100) local.float

			}


			local.i++
			local.y += 18

			huddraw_font (local.i + 100) "verdana-12"

			local.string = ("Playerset: " + level.playernodeset)
			huddraw_string (local.i + 100) local.string

			huddraw_align (local.i + 100) left top
			huddraw_rect (local.i + 100) 0 local.y 0 0
			huddraw_alpha (local.i + 100) local.float


			local.i++
			local.y += 18

					huddraw_font (local.i + 100) "verdana-12"

					local.string = " "
					local.stringcount = 1

				for (local.p=1;local.p<level.friendlynodes+1;local.p++)
				{
					local.stringcount++
					if (local.stringcount > 12)
					{
						local.string = (local.string + "\n")
						local.stringcount = 0
					}

				if (level.friendlyused[local.p] == 0)
					local.string = (local.string + "0")
					else
					local.string = (local.string + level.friendlyused[local.p])
				}

					huddraw_string (local.i + 100) local.string

					huddraw_align (local.i + 100) left top
					huddraw_rect (local.i + 100) 0 local.y 0 0
					huddraw_alpha (local.i + 100) local.float



		}
		wait 1 
	}
end


friendlyused local.num:

	if ((level.friendlyused[local.num] == 0) || (level.friendlyused[local.num] == 1))
	{
		level.friendlyused[local.num] = 1
		level.friendlyusedtime[local.num] = level.time + level.friendlyusedtimeupdate
	}

end


settrigger:
	level waittill spawn
	level.enemyset[self.group]++

	self waittill death

	level.enemyset[self.group]--
	println ("*******set**** " + level.enemyset[self.group] + " left in " + self.group)

	if (level.enemyset[self.group] < 1)
		thread level.script::("enemythread" + self.group)
	
end



areatrigger local.waitspawn:
//	println ("localwaitspawn is " + local.waitspawn)
	if (local.waitspawn != NIL)
		level waittill spawn

	if (level.friendlynodes == NIL)
		end

//	println ("health is " + self.health)
	
	level.enemyarea[self.area]++

	if (getcvar(debug) == "1")
		println ("Areatrigger " + self.area + " has " + level.enemyarea[self.area] + " enemies in it")

	for (local.i=1;local.i<level.friendlynodes+1;local.i++)
	{
		if (level.friendlynode[local.i].area == self.area)
			level.friendlyused[local.i] = 0
	}

//	println ("self is " + self.targetname + " and self area is " + self.area)

	self waittill death
//	println self.health

	level.enemyarea[self.area]--
	println ("*******area**** " + level.enemyarea[self.area] + " left in " + self.area)

	if (level.enemyarea[self.area] < 1)
	{
		for (local.i=1;local.i<level.friendlynodes+1;local.i++)
		{
			if (level.friendlynode[local.i].area == self.area)
				level.friendlyused[local.i] = -1
		}
	}

	
end

friendlydeath:
{
	level waittill spawn
	
	//[205] chrissstrahl - fixed NULL entity reference issue
	if(!self){ end }
	
	self waittill death
	for (local.i=1;local.i<level.friendlys+1;local.i++){
		if (level.friendly[local.i] == self){
			level.friendly[local.i] = level.deadent
		}
	}
}end


/*

					if (vector_length(self.origin - self.destination.origin) > self.distance + local.friendrange)
					{
						self runto self.destination
						local.runtime = level.time + 2

						while ((vector_length (self.origin - self.destination.origin) > self.distance - local.friendrange))
							wait self.waittime

//						if (parm.movedone != 1)
//							println (self + " did not get to " + self.destination.set)
					}


					if (vector_length (self.destination.origin - self.origin) > self.distance + local.friendrange) 
					{
						self runto self.destination.origin
						if (self.waittime == -1)
							waitframe
						else
							wait self.waittime


					}
					else
					if (vector_length (self.destination.origin - self.origin) < self.distance) 
					{
						local.standtime = level.time + 0.1
						if (local.stood == 0)
						{
							self exec global/stand.scr
							local.stood = 1
						}

						if (self.waittime == -1)
							waitframe
						else
							wait self.waittime


					}
*/
			/*
		
				if (level.frienddebug == 1)
				if (level.time > local.runtime)
				{
					local.runtime = level.time + 2
					print ("dist: " + self.distance + "     ")
					if (self.destination == $player)
					println (self + "/" + self.fnum + " is supposed to run to " + self.destination)
					else
					println (self + "/" + self.fnum + " is supposed to run to " + self.destination + "/" + self.destination.fnum)

				}

				if !(isalive self.destination)
				{
					if (self.area != -1)
					{
						self.friendtype = self.areapast
					}
					else
					{
						if ((self.destination.destination != NIL) && (isalive self.destination.destination))
							self.destination = self.destination.destination
						else
							self.destination = $player
					}
				}

				if (self.destination != $player)
				for (local.i=1;local.i<level.friendlys+1;local.i++)
				{
					if (isalive level.friendly[local.i])
					{
						if (((self.area == -1) && (level.friendly[local.i].area != -1)) || ((level.friendly[local.i].destination == self.destination) && (self != level.friendly[local.i])))
							self.destination = level.friendly[local.i]
					}
				}

				if (level.time > local.standtime)
				{
					local.destination = self.destination
					local.tempnum = 0
					while ((isalive local.destination.destination) && (self.destination != $player) && (local.tempnum < 10))
					{
						local.tempnum++
						if (local.destination == self)
							self.destination = $player

							local.destination = local.destination.destination
					}

					if (vector_length (self.destination.origin - self.origin) > self.distance + local.friendrange) 
					{
						local.runtime = level.time + 5
						self runto self.destination.origin
						if (self.waittime == -1)
							waitframe
						else
							wait self.waittime
					}
					else
					if (vector_length (self.destination.origin - self.origin) < self.distance) 
					{
						local.standtime = level.time + 2
	//					self runto self
						self exec global/stand.scr
						if (self.waittime == -1)
							waitframe
						else
							wait self.waittime
					}
				}

					thread repulse

			}
			*/

	/*
				if (level.time > local.runtime)
				{
					local.entarray = -1
					local.entarrayentree = 0
					
					local.setnum = -1
					local.nodenum = -1

					if ((self.destinationset < level.playernodeset + self.mins) || (self.destinationset > level.playernodeset + self.maxs))
					{
						
						for (local.i=1;local.i<level.friendlynodes+1;local.i++)
						{
							if (self.destination.set == NIL)
								self.destination = level.friendlynode[1]

							if ((level.friendlynode[local.i].set > self.destinationset) && (local.setnum < level.friendlynode[local.i].set) && ((level.friendlynode[local.i].set > level.playernodeset + self.mins) && (level.friendlynode[local.i].set < level.playernodeset + self.maxs) && (level.friendlyused[local.i] == 0)) && (self.lastdestination != level.friendlynode[local.i]) && (self.destinationset != level.friendlynode[local.i].set))
							{
									local.setnum = level.friendlynode[local.i].set
									local.nodenum = local.i

								if (local.nodenum != -1)
								{

									if (level.friendlyused[self.destinationnum] == 1)
										level.friendlyused[self.destinationnum] = 0

									self.destinationnum = local.nodenum
									thread friendlyused self.destinationnum
									self.destination = level.friendlynode[local.nodenum]
									self.destinationset = level.friendlynode[local.nodenum].set
								}
							}
						}
					}

					if (vector_length(self.origin - self.destination.origin) > self.distance + local.friendrange)
					{
						self thread ailook0


						self runto self.destination
						local.runtime = level.time + 2

						while ((vector_length (self.origin - self.destination.origin) > self.distance - local.friendrange) && (level.playernodeset > self.destinationset + self.mins) && (level.playernodeset < self.destinationset + self.maxs))
							wait self.waittime

			
						self.lookthread delete
					}
					else
					{
						wait 1
						thread friendlyused self.destinationnum
					}

					self.lastdestination = self.destination
				}

	*/
/*

	self runto such&such
	self waittill move
	if (parm.movefail != 1)
		self waittill movedone
		else
*/

testprint local.o:
	local.t = level.time + 4
	while (local.t > level.time)
	{
		print3d local.o 2 "000"
		waitframe
	}
end

nicetrace local.start local.dest:
	//[202] chrissstrahl
	//if (local.start != $player)
	if (local.start.classname != "Player")
	{
		if (local.start cansee local.dest 360)
			end 1

		if (local.dest cansee local.start 360)
			end 1
	}

	if (local.start canseenoents local.dest)
		end 1

	if (local.start canseenoents local.dest.origin)
		end 1

	if (local.start canseenoents (local.dest.origin + (0 0 35)))
		end 1

	if (local.start canseenoents (local.dest.origin + (0 0 70)))
		end 1

end -1


lookpast local.see:
	local.vect = (local.see.origin - self.origin)
	local.vect = vector_normalize (local.vect)

//	local.dist = vector_length (self.origin - local.dest.origin)
	
	local.vect[0] = 	local.vect[0] * (40)
	local.vect[1] = 	local.vect[1] * (40)
	local.vect[2] = 	local.vect[2] * (40)

//	local.o = (self.origin - local.see.origin) + local.see.origin
	local.vect = local.see.origin + local.vect
	self lookat local.vect
//	thread testprint local.vect

end

lookpastlow local.see local.delay:
	if (local.delay != NIL)
		wait local.delay
	local.vect = ((local.see.origin + (0 0 70)) - self.origin)
	local.vect = vector_normalize (local.vect)

//	local.dist = vector_length (self.origin - local.dest.origin)
	
	local.vect[0] = 	local.vect[0] * (40)
	local.vect[1] = 	local.vect[1] * (40)
	local.vect[2] = 	local.vect[2] * (40)

	local.vect = (local.see.origin + (0 0 70)) + local.vect
	self lookat local.vect
//	thread testprint local.vect
end

chain_off local.set:
	for (local.i=1;local.i<level.friendlynodes+1;local.i++)
	if ((level.friendlynode[local.i].chain_set) && (level.friendlynode[local.i].chain_set == local.set))
		level.friendlyused[local.i] = 1
end

chain_on local.set:
	for (local.i=1;local.i<level.friendlynodes+1;local.i++)
	if ((level.friendlynode[local.i].chain_set) && (level.friendlynode[local.i].chain_set == local.set))
		level.friendlyused[local.i] = 0
end

chain_all_on local.set:
	for (local.i=1;local.i<level.friendlynodes+1;local.i++)
	if (level.friendlynode[local.i].chain_set)
		level.friendlyused[local.i] = 0
end

chain_all_off local.set:
	for (local.i=1;local.i<level.friendlynodes+1;local.i++)
	if (level.friendlynode[local.i].chain_set)
		level.friendlyused[local.i] = 1
end

// I'm testing
