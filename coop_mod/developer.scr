//chrissstrahl - since the game refuses to let me use cheats in multiplayer
//I am fucking gonna use this shitt, ya, screw you bitch! I WIN!!!1111
//
//Contains developer related commands that are needed for proper map testing
//

//[203] chrissstrahl - updated and changed
//commands that are extracted from netname, see player.scr::manageNamechange
//=========================================================================
devcommand local.data:{
//=========================================================================
	if(!local.data){ iprintlnbold_noloc("GO SLEEP! YOU ARE SLIPPING.");end }
	
	//show developer menu
	if(waitthread coop_mod/main.scr::containsText local.data "ui" game.false){
		self stufftext ("pushmenu coopdev\n")
		end
	}
	
	//println("COOPDEBUG: devcommand")

	local.devCommand["lgn"] = "login"			//log developer in
	
	local.devCommand["stst"] = "spawnpoints"	//test if existing spawns are working
	local.devCommand["sexs"] = "spawnpointsshow"	//test if existing spawns are working
	
	local.devCommand["snew"] = "spawnmarkers"	//spawns markers for every player spawn based on current player pos to show if it could work
	local.devCommand["stry"] = "testmarkers"	//?
	local.devCommand["sprt"] = "printmarkers"	//prints consoleoutput based on current status of spawnmarkers
												//used to copy them out of the logfile and put them into spawnlocations.scr
	local.devCommand["tch"] = "showtouch"		//print info of object touched by developer
	local.devCommand["ncl"] = "noclip"			//toggels noclip
	local.devCommand["tht"] = "threatbias"		//toggels threatbias
	
	local.devCommand["heal"] = "heal"			//heal self
	local.devCommand["fhea"] = "healfriendly"	//heal friendly
	
	local.devCommand["msts"] = "printmissionstatus"	//prints consoleoutput with all mission relevant statusinfos
	
	local.devCommand["acti"] = "threadorentity"	//runs script thread or fires a trigger given by name
	
	local.devCommand["pos"] = "printposandshowmarker"	//runs script thread or fires a trigger given by name
	
	//if the command was found execute it
	if(local.devCommand[local.data] != NIL){
		if(	local.devCommand[local.data] != "login" &&
			thread coop_mod/main.scr::checkCoopDeveloper local.devCommand["lgn"])
		{
			end
		}
	
		self stufftext ("popmenu 0;cg_3rd_Person 0")
		self thread (local.devCommand[local.data])
	}else{
		self iprint ("devcommand unsupported command: "+local.devCommand[local.data]) 1
	}
}end
	
//[203] chrissstrahl - place a marker and print pos and angle to console
//this is used 
//=========================================================================
printposandshowmarker:{
//=========================================================================
	if(level.printMarkerIndex == NIL){
		level.printMarkerIndex = 0
	}
	level.printMarkerIndex++
	self iprint ( "Marker ["+level.printMarkerIndex+"] set and print to console") 1 NIL
	local.originz = self.origin
	local.originz[2] += 10
	local.anglez = ( 0 0 0 )
	local.anglez[1] = self.angle
	local.ent = spawn script_model model "models/vehicles/uboat.tik" origin local.originz notsolid 1 scale 0.04 angles local.anglez
	
	local.originz = self.origin
	local.originz[2] += 80
	local.ent = spawn script_model model "models/vehicles/c47fly.tik" origin local.originz notsolid 1 scale 0.08 angles local.anglez
	
	local.playerCleanName = waitthread coop_mod/player.scr::playerCleanName self.netname
	waitthread printtoserverandclient ("==HZM Coop Dev: MARKER "+local.playerCleanName+" @ "+level.coop_mapname+" ["+level.printMarkerIndex+"] "+local.originz+" - "+local.anglez) self
}end

//[203] chrissstrahl - execut a script thread or activate a entity (trigger)
//=========================================================================
threadorentity:{
//=========================================================================
	self iprint ( "threadorentity") 1 NIL
	if(level.coopThreadorEntity){
		self iprint ( "Allready Running!") 1 NIL
		end
	}
	if(level.coopThreadorEntityIndex==NIL){level.coopThreadorEntityIndex=1}
	level.coopThreadorEntity=1
	
	local.playerCleanName = waitthread coop_mod/player.scr::playerCleanName self.netname
	
	println ( "EXECUTE THREAD OR TRIGGER "+level.coopThreadorEntityIndex+" for "+local.playerCleanName)
	self iprint ( "EXECUTE THREAD OR TRIGGER "+level.coopThreadorEntityIndex+" for "+local.playerCleanName) 1 NIL
	
	wait 1
	
	if(!self){
		goto threadorentity_end
	}
	
	self iprint ( "Set your playername to the thread or targetname to activate.") 0 NIL
	self iprint ( "example: objective123") 1 NIL
	self iprint ( "example: $spawnenemy5") 1 NIL
	
	//wait for player to rename
	local.playerCleanName = self.netname
	local.timeout=600 //600=30 sec with sv_fps 20
	while(self && local.playerCleanName == self.netname && local.timeout > 0){
		waitframe
		local.timeout--
	}
	
	if(!local.timeout){
		self iprint ( "Execute Entity or Thread timmed out, you took to long to rename") 1 NIL
		goto threadorentity_end
	}
	
	local.name = self.netname
	if(!local.name || local.name == "" || local.name.size < 2){
		goto threadorentity_end
	}
	
	//developer wants to trigger a entity
	if(local.name[0] == "$"){
		local.targetname = waitthread coop_mod/main.scr::cleanText local.name "$" NIL
		
		local.entity = $(""+local.targetname)
		if(local.entity){
			println ( "ENTITY TRIGGERED: "+local.name+" for "+local.playerCleanName)
			self iprint ( "ENTITY TRIGGERED: "+local.name) 1 NIL
			self trigger local.entity
		}else{
			println ( "ENTITY NOT FOUND: "+local.name+" for "+local.playerCleanName)
			self iprint ( "ENTITY NOT FOUND: "+local.name) 1 NIL
		}
	}
	//developer wants to start a thread
	else{
		self iprint ( "STARTING THREAD: "+("maps/"+level.coop_mapname+".scr::"+local.name)) 1 NIL
		print ( "STARTING THREAD: "+("maps/"+level.coop_mapname+".scr::"+local.name)+" for "+local.playerCleanName)
		thread coop_mod/main.scr::startThread ( ("maps/"+level.coop_mapname+".scr::"+local.name) ) self
	}
	
	//rename player back
	wait 1
	if(self){
		self stufftext ("name "+local.playerCleanName)
	}
	
	threadorentity_end:
	
	level.coopThreadorEntity=0
}end

//[203] chrissstrahl - print the missionstatus to server log
//=========================================================================
printtoserverandclient local.text local.player:{
//=========================================================================
	println(local.text)
	if( level.coop_dedicated &&  local.player ){
		local.player stufftext ("echo "+local.text+"\n")
	}
}end

//[203] chrissstrahl - print the missionstatus to server log
//=========================================================================
returnObjectiveStatusDescr local.status:{
//=========================================================================
	local.status = int(local.status)
	if(local.status==1){
		end "DONOTDRAW"
	}else if(local.status==2){
		end "INPROGRESS"
	}else if(local.status==3){
		end "COMPLETED"
	}else{
		end "UNHANDLED"
	}
}end

//[203] chrissstrahl - print the missionstatus to server log
//=========================================================================
printmissionstatus:{
//=========================================================================
	if(level.coopPrintMissionStatus){ end }
	if(level.coopMissionStatusIndex==NIL){level.coopMissionStatusIndex=0}
	level.coopPrintMissionStatus=1
	level.coopMissionStatusIndex++
	
	local.playerCleanName = waitthread coop_mod/player.scr::playerCleanName self.netname
	self iprint ( "Printed Missions Status "+level.coopMissionStatusIndex+" into Server console for "+local.playerCleanName) 1 NIL
	
	//enable logging on server
	local.logfile = int(getcvar("logfile"))
	if(!local.logfile){
		setcvar ( "logfile 1" )
	}
	
	//activate logfile for dev client
	if( level.coop_dedicated &&  self ){
		local.player stufftext "logfile 1"
	}
	waitframe
	waitthread printtoserverandclient ("==HZM Coop Dev: "+local.playerCleanName+" @ "+level.coop_mapname+" Status "+level.coopMissionStatusIndex) self
	
	waitthread printtoserverandclient ("==-----------------PLAYERS") self
	for (local.pl = 1;local.pl <= $player.size;local.pl++){
		local.player =  $player[local.pl]
		if(local.player){
			local.playerCleanName = waitthread coop_mod/player.scr::playerCleanName local.player.netname
			waitthread printtoserverandclient ("==Player["+local.pl+"] "+local.playerCleanName+" E:"+local.player.entnum+" H:"+local.player.health+" T:"+local.player.dmteam+"") self
			waitthread printtoserverandclient ("level.flags[coop_spawn"+local.pl+"origin] = "+local.player.origin) self
			waitthread printtoserverandclient ("level.flags[coop_spawn"+local.pl+"angles] = ( 0 "+local.player.angle+" 0 )") self
		}
	}
	
	waitthread printtoserverandclient ("==-----------------FRIENDLIES")
	if(level.friendly1){ waitthread printtoserverandclient ("level.friendly1 "+level.friendly1.targetname+" E:"+level.friendly1.entnum+" H:"+level.friendly1.health+" O:"+level.friendly1.origin+" A: "+level.friendly1.angles+" T:"+level.friendly1.friendtype) self }
	if(level.friendly2){ waitthread printtoserverandclient ("level.friendly2 "+level.friendly2.targetname+" E:"+level.friendly2.entnum+" H:"+level.friendly2.health+" O:"+level.friendly2.origin+" A: "+level.friendly2.angles+" T:"+level.friendly2.friendtype) self }
	if(level.friendly3){ waitthread printtoserverandclient ("level.friendly3 "+level.friendly3.targetname+" E:"+level.friendly3.entnum+" H:"+level.friendly3.health+" O:"+level.friendly3.origin+" A: "+level.friendly3.angles+" T:"+level.friendly3.friendtype) self }
	if(level.friendly4){ waitthread printtoserverandclient ("level.friendly4 "+level.friendly4.targetname+" E:"+level.friendly4.entnum+" H:"+level.friendly4.health+" O:"+level.friendly4.origin+" A: "+level.friendly4.angles+" T:"+level.friendly4.friendtype) self }
	if(level.friendly5){ waitthread printtoserverandclient ("level.friendly5 "+level.friendly5.targetname+" E:"+level.friendly5.entnum+" H:"+level.friendly5.health+" O:"+level.friendly5.origin+" A: "+level.friendly5.angles+" T:"+level.friendly5.friendtype) self }
	if(level.friendly6){ waitthread printtoserverandclient ("level.friendly6 "+level.friendly6.targetname+" E:"+level.friendly6.entnum+" H:"+level.friendly6.health+" O:"+level.friendly6.origin+" A: "+level.friendly6.angles+" T:"+level.friendly6.friendtype) self }
	
	waitthread printtoserverandclient ("==-----------------OBJECTIVES")
	if(level.coopObjective1Text != NIL){ waitthread printtoserverandclient ( "Objective 1: ["+waitthread returnObjectiveStatusDescr level.coopObjective1+"] "+level.coopObjective1Text) self }
	if(level.coopObjective2Text != NIL){ waitthread printtoserverandclient ( "Objective 2: ["+waitthread returnObjectiveStatusDescr level.coopObjective2+"] "+level.coopObjective2Text) self }
	if(level.coopObjective3Text != NIL){ waitthread printtoserverandclient ( "Objective 3: ["+waitthread returnObjectiveStatusDescr level.coopObjective3+"] "+level.coopObjective3Text) self }
	if(level.coopObjective4Text != NIL){ waitthread printtoserverandclient ( "Objective 4: ["+waitthread returnObjectiveStatusDescr level.coopObjective4+"] "+level.coopObjective4Text) self }
	if(level.coopObjective5Text != NIL){ waitthread printtoserverandclient ( "Objective 5: ["+waitthread returnObjectiveStatusDescr level.coopObjective5+"] "+level.coopObjective5Text) self }
	if(level.coopObjective6Text != NIL){ waitthread printtoserverandclient ( "Objective 6: ["+waitthread returnObjectiveStatusDescr level.coopObjective6+"] "+level.coopObjective6Text) self }
	if(level.coopObjective7Text != NIL){ waitthread printtoserverandclient ( "Objective 7: ["+waitthread returnObjectiveStatusDescr level.coopObjective7+"] "+level.coopObjective7Text) self }
	if(level.coopObjective8Text != NIL){ waitthread printtoserverandclient ( "Objective 8: ["+waitthread returnObjectiveStatusDescr level.coopObjective8+"] "+level.coopObjective8Text) self }

	waitthread printtoserverandclient ("==end of MISSION Status") self
	
	
	waitframe
	if(!local.logfile){
		setcvar ( "logfile 0" )
	}
	level.coopPrintMissionStatus=0
}end

//[203] chrissstrahl - login developer
//=========================================================================
login:{
//=========================================================================
	if(self.flags["coopDeveloperVerified"] == 1){
		self iprint ("You are already logged in!") 1 NIL
		end
	}/*
	else if(self.flags["coop_isHost"] == 1){
		self.flags["coopDeveloperVerified"] = 1
		self iprint ("You are now logged in!") 1 NIL
		end
	}*/
	else{		
		level.momLoginDeveloperIndex = 0;
		level.developerLoginCode = ""
		self thread mom/mom.scr::setup "coop_mod/mom_login.scr" NIL coop_login 1
		self thread mom/mom.scr::momManagePlayer
	}
}end

//[202] chrissstrahl
//used for developer to spot relevant objects while testplaying (makeing them blink)
//=========================================================================
timescale local.timeScale:{
//=========================================================================
	if(level.coop_devTimescaleOn){
		setcvar "timescale" local.timeScale
	}
}end

//[202] chrissstrahl
//used for developer to spot relevant objects while testplaying (makeing them blink)
//=========================================================================
blinkMe local.pulseTime:{
//=========================================================================
	if(!local.pulseTime){
		local.pulseTime = 0.05
	}
	while(self){
		self hide
		wait local.pulseTime
		if(!self){ end }
		self show
		wait 2
	}
}end


//this was specifically desiged to test ohama beach without coop mod
//=========================================================================
spawnUpdater:{
//=========================================================================
//chrissstrahl - temp fixme
while($player == NULL || $player.size < 1){
	waitframe
}
	//mäke süre the pläyer will respäwn where he died düring this test phäse, sö the script döes nöt bräke
	local.lastpos = (0 0 0)
	while($player.size < 2){
		if($player.dmteam != "spectator"){
			if($player.health == 100 && $player.flags["chrissstrahlMove"] != NIL && local.lastpos != (0.000000 0.000000 0.000000)){
				$player origin local.lastpos
				$player.flags["chrissstrahlMove"] = NIL
				//iprintlnbold_noloc("DEV: You have been moved to your last safe pos("+local.lastpos+").")
			}else if($player.health < 100){
				if($player.health <= 0){
					$player.flags["chrissstrahlMove"] = 1
					waitframe
					//iprintlnbold_noloc("DEV: dead.")
				}else{
					//iprintlnbold_noloc("DEV: lastpos.")
					local.lastpos = $player.origin				
				}
			}
		}
		wait 0.25
	}
	iprintlnbold_noloc("DEV: spawnupdater ENDED more than 1 player!!!")
}end


//MOM related
//=========================================================================
noclip:{
//=========================================================================
	if( self == NULL || self.health <= 0 ){
		end
	}
	
	self noclip
	
	if(self.flags["coopDevNoclip"] != NIL){
		self.flags["coopDevNoclip"] = NIL
		self iprint ( "[NOCLIP] off" ) 1 NIL
		self notsolid
		thread coop_mod/main.scr::playerMakeSolidAsap self
	}else{
		self iprint ( "[NOCLIP] ON" ) 1 NIL
		self.flags["coopDevNoclip"] = 1
	}
}end

//MOM related
//=========================================================================
heal:{
//=========================================================================
	//[200] chrissstrahl - check if developer needs to be on
	if(thread coop_mod/main.scr::checkCoopDeveloper "Heal command"){ end }
	
	if( self == NULL || self.health <= 0 ){
		end
	}
	
	self iprint ( "[HEAL] You are healed to: "+self.health ) 1 NIL
	self heal 1
}end

//MOM related
//=========================================================================
healfriendly:{
//=========================================================================
	//[200] chrissstrahl - check if developer needs to be on
	if(thread coop_mod/main.scr::checkCoopDeveloper "Heal friendly command"){ end }

	self iprint ( "[HEAL] You healed your friendlies" ) 1 NIL
	
	if(level.friendly1)
		level.friendly1 heal 1
		
	if(level.friendly2)
		level.friendly2 heal 1
	
	if(level.friendly3)
		level.friendly3 heal 1
	
	if(level.friendly4)
		level.friendly4 heal 1
	
	if(level.friendly5)
		level.friendly5 heal 1
	
	if(level.friendly6)
		level.friendly6 heal 1
	
	self heal 1
}end

//moves developer trough spawnpoint locations, waiting for dev to move away
//=========================================================================
spawnpoints:{
//=========================================================================
	//[200] chrissstrahl - check if developer needs to be on
	if(thread coop_mod/main.scr::checkCoopDeveloper "Test Spawnpoints command"){ end }
	
	if( self == NULL || self.health <= 0 || self.dmteam == "spectator"){
		end
	}
	
	if(self.flags["coopDevSpawnpointsTest"] != NIL){
		self.flags["coopDevSpawnpointsTest"] = NIL
		end
	}
	self.flags["coopDevSpawnpointsTest"] = 1
	
	self iprint ( "Test is spawnpoints active for you!" ) 1
	self nodamage
	
	for(local.i=1;local.i<=8;local.i++){
		if( self == NULL ){ end }
		
		if( self.flags["coopDevSpawnpointsTest"] == NIL  || self.health <= 0 ){
			self iprint ( "Testing spawnpoints was STOPPED!" ) 1
			self takedamage
			end
		}

		local.vec = level.flags["coop_spawn"+local.i+"origin"]
		
		if(local.vec == NIL){
			self iprint ( "coop_spawn"+local.i+"origin was NIL!" ) 1
			continue
		}
		
		self forcelegsstate STAND
		self tele local.vec
		
		//if no angle defined use default
		local.viewang = level.flags["coop_spawn"+local.i+"angles"]
		if(local.viewang == NIL){
			local.viewang = level.flags["coop_spawn1angles"]
		}
		self thread coop_mod/main.scr::playerFace local.viewang
		
		self iprint ( "You are testing spawnpoint ["+local.i+"]. Move away now!" ) 1
		
		while( self != NULL && self.health > 0 &&
				vector_length( local.vec - self.origin) < 100 &&
				local.i<8 && self.dmteam != "spectator" &&
				self.flags["coopDevSpawnpointsTest"] != NIL){
			waitframe
		}
		if(local.i<8){
			wait 1
		}
	}
	self iprint ( "Spawnpoint Test complete" ) 1 NIL
	self takedamage
}end

//=========================================================================
spawnpointsshow:{ //
//=========================================================================
	self iprint ("TOGGLE spawnpointsshow") 1
	
	//remove markers
	if(level.coopShowExistingSpawnpoints != NIL){
		for(local.i=1;local.i<=8;local.i++){
			local.entityMarker = $("coopEMkr"+local.i)
			if(local.entityMarker){
				local.entityMarker delete
			}
		}
		level.coopShowExistingSpawnpoints=NIL
		end
	}
	level.coopShowExistingSpawnpoints=1
	
	//add markers
	for(local.i=1;local.i<=8;local.i++){
		local.vec = level.flags["coop_spawn"+local.i+"origin"]
		
		if(!(local.vec)){
			self iprint ("coop_spawn"+local.i+"origin was EMPTY/NIL") 1
		}
		//local.vec_z += 20
		
		local.angles = level.flags["coop_spawn"+local.i+"angles"]
		if(!(local.angles)){
			local.angles = level.flags["coop_spawn1angles"]
			if(!(local.angles)){
				local.angles = "( 0 0 0 )"
			}
		}
		
		//spawn script_model model "models/items/torpedo.tik" origin (local.vec) notsolid 1 targetname ("coopEMkr"+local.i) scale 1 angle -1
		local.ent = spawn script_model model "models/player/german_Worker.tik" origin (local.vec) notsolid 1 targetname ("coopEMkr"+local.i) scale 1 angles local.angles
		waitframe
		local.ent anim "unarmed_stand_walk_fwd"
	}
	
	//update location if it has changed
	while(level.coopShowExistingSpawnpoints){
		for(local.i=1;local.i<=8;local.i++){
			local.entityMarker = $("coopEMkr"+local.i)
			if(local.entityMarker != NULL){
				local.vec = level.flags["coop_spawn"+local.i+"origin"]
				if(local.vec != local.entityMarker.origin){
					local.angles = level.flags["coop_spawn"+local.i+"angles"]
					if(!(local.angles)){
						local.angles = level.flags["coop_spawn1angles"]
						if(!(local.angles)){
							local.angles = "( 0 0 0 )"
						}
					}
					local.entityMarker origin local.vec
					local.entityMarker angles local.angles
				}
			}
		}
		wait 1
	}
}end


//MOM related
//=========================================================================
makeweak:{
//=========================================================================	
	iprintlnbold_noloc ( "developer make enemies weak" )
	iprintlnbold_noloc ( "incomplete" )
}end


//MOM related
//=========================================================================
showtouch:{
//=========================================================================
	//end touch
	if(self.flags["coop_momShowTouch"] != NIL){
		self.flags["coop_momShowTouch"] = NIL
		exec coop_mod/main.scr::printInfo self ( "Show TOUCH OFF" ) 1 NIL
		end
	}

	exec coop_mod/main.scr::printInfo self ("Show TOUCH ON" ) 1 NIL
	self.flags["coop_momShowTouch"] = 1
	
//prints out a message what the player is touching
//this is used for debugging objects that are hard to find otherwise
	while(self != NULL && self.flags["coop_momShowTouch"] != NIL){
		local.maxentities = int(getcvar("maxentities"))	
		//check every entity
		local.ent = NULL
		for (local.i = 0; local.i < local.maxentities; local.i++) {
			local.ent = getentbyentnum local.i
			//exists and has a model (is a tiki)
			
			if(local.ent != NULL && self istouching local.ent && local.ent.model != NIL && local.ent.model.size > 6){
				//filter weapons and player (current weapon and playermodel)
				if(waitexec coop_mod/main.scr::containsText local.ent.model "weapons/" ||
					local.ent.entnum == self.entnum){
					//waitexec coop_mod/main.scr::containsText local.ent.model "player/"){
					//exec coop_mod/main.scr::printInfo $player[1] "touching a weapon" 1 NIL
				}else{// if(waitexec coop_mod/main.scr::containsText local.ent.model "/"){
					local.vec = local.ent.origin
					local.model = waitexec coop_mod/strings.scr::remove local.ent.model "models/"
					exec coop_mod/main.scr::printInfo self ("[touching] @ "+level.coop_mapname+" $"+local.ent.targetname+": "+local.model+" at "+int(local.vec[0])+" "+int(local.vec[1])+" "+int(local.vec[2])) 1 NIL 10
					local.ent thread dev_blink self 0.5
				}
			}
		}
		wait 1		
	}
}end


//MOM related
//=========================================================================
notarget:{
//=========================================================================
	self notarget
	self iprint "toggled notarget" 1
}end


//MOM related
//=========================================================================
threatbias:{
//=========================================================================
	if(self.flags["mom_coopThreatbias"] == NIL){
		self.flags["mom_coopThreatbias"] = 1
		self threatbias ignoreme
		self iprint "threatbias ignoreme" 1
	}else{
		self.flags["mom_coopThreatbias"]= NIL
		self threatbias 1
		self iprint "threatbias 1" 1
	}
}end

//[202] chrissstrahl - changed with [203]
//creates a preview of how spawnspots would look at this clocation
//=========================================================================
spawnmarkers:{
//=========================================================================
	local.angles = self.viewangles
	local.angles[0] = 0
	local.angles[2] = 0
	
	//[203] chrissstrahl - if cycle is already active wait exit until it is ended
	if(level.spawnmarkersManage){
		self iprint "Markers are already active, move away and press use to stop." 1
		end
	}
	level.spawnmarkersManage = 1
	self iprint "Press use to cycle placement options." 1
	
	//make sure markers are spawned
	self waitthread spawnmarkers_spawn
	
	//set viewangle
	for(local.i=1;local.i<=8;local.i++){
		$("coopSMkr"+local.i) angles local.angles
	}
	
	self thread spawnmarkersManage
}end

//[203] chrissstrahl
//allows the developer to step away and cycle the spawnlocation pattern
//=========================================================================
spawnmarkersManage:{
//=========================================================================
	local.origin = self.origin
	self thread spawnmarkersCycle local.origin
	while(self && self.health > 0 && level.spawnmarkersManage){
		if(self.useheld){
			if(vector_length(local.origin - self.origin) > 512){
				level.spawnmarkersManage = 0
			}else{
				self thread spawnmarkersCycle local.origin
				wait 1			
			}
		}
		waitframe
	}
	if(self){
		self iprint "Markers cycle function has stopped." 1
	}
	
	level.spawnmarkersManage = 0
	for(local.i=1;local.i<=8;local.i++){
		$("coopSMkr"+local.i) remove
	}
	$world.flag["coop_dev_spawnmarkers"] = NIL
}end

//[203] chrissstrahl
//cycles the spawnlocation pattern
//=========================================================================
spawnmarkersCycle local.origin:{
//=========================================================================
	local.maxcombinations = 7
	local.devcoopspawnmarkers = $world.flag["coop_dev_spawnmarkers"]
	if(local.devcoopspawnmarkers == NIL || local.devcoopspawnmarkers >= local.maxcombinations){
		$world.flag["coop_dev_spawnmarkers"] = 1
		local.devcoopspawnmarkers = 1
	}else{
		$world.flag["coop_dev_spawnmarkers"] = (local.devcoopspawnmarkers + 1)
		local.devcoopspawnmarkers++
	}
	
	self iprint ("Spawn Markers Cycle "+local.devcoopspawnmarkers+"") 1
	
	local.testorigin = local.origin
	
	$coopSMkr1 scale 0.5
	waitframe
	
	//place spawns as straight line with the player in the center +x and -x
	//////////////////////////////////////////
	if(local.devcoopspawnmarkers == 1){		
		for(local.i=1;local.i<=4;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] += 40
		}
		local.testorigin = local.origin
		local.testorigin[0] -= 40
		for(local.i=5;local.i<=8;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] -= 40
		}
	}
	//place spawns as straight line with the player in the center +y and -y
	//////////////////////////////////////////
	else if(local.devcoopspawnmarkers == 2){
		for(local.i=1;local.i<=4;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[1] += 40
		}
		local.testorigin = local.origin
		local.testorigin[1] -= 40
		for(local.i=5;local.i<=8;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[1] -= 40
		}
	}
	//place spawns as straight line with the player in the center +y+x and -y-x
	//////////////////////////////////////////
	else if(local.devcoopspawnmarkers == 3){
		for(local.i=1;local.i<=4;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] += 40
			local.testorigin[1] += 40
		}
		local.testorigin = local.origin
		local.testorigin[0] -= 40
		local.testorigin[1] -= 40
		for(local.i=5;local.i<=8;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] -= 40
			local.testorigin[1] -= 40
		}
	}
	//place spawns as straight line with the player in the center +y+x and -y-x
	//////////////////////////////////////////
	else if(local.devcoopspawnmarkers == 4){
		for(local.i=1;local.i<=4;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] -= 40
			local.testorigin[1] += 40
		}
		local.testorigin = local.origin
		local.testorigin[0] += 40
		local.testorigin[1] -= 40
		for(local.i=5;local.i<=8;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] += 40
			local.testorigin[1] -= 40
		}
	}
	//place spawns like a 8th-pack with player in the center
	//////////////////////////////////////////
	else if(local.devcoopspawnmarkers == 5){
		//Row 1 1+2
		for(local.i=1;local.i<=2;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] += 40
		}
		//Row 1 3+4
		local.testorigin = local.origin
		local.testorigin[0] -= 40
		for(local.i=3;local.i<=4;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] -= 40
		}
		
		//row 2 - 5 to 8
		local.testorigin = local.origin
		
		local.testorigin[0] -= ( 40 * 2 )
		local.testorigin[1] -= 50
		for(local.i=5;local.i<=8;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] += 40
		}
	}
	//place spawns like a x pattern player in the center
	//////////////////////////////////////////
	else if(local.devcoopspawnmarkers == 6){
		local.testorigin[0] -= ( 40 * 2 )
		local.testorigin[1] -= ( 40 * 2 )
		
		local.originBaseline = local.testorigin
	
		for(local.i=1;local.i<=4;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] += 40
			local.testorigin[1] += 40
			if(local.i==2){
				local.testorigin[0] += 40
				local.testorigin[1] += 40
			}
		}
		
		local.testorigin = local.originBaseline
		local.testorigin[0] += (40 * 4)	

		for(local.i=5;local.i<=8;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] -= 40
			local.testorigin[1] += 40
			if(local.i==6){
				local.testorigin[0] -= 40
				local.testorigin[1] += 40
			}
		}
	}
	//place spawns two per row, center player
	//////////////////////////////////////////
	else if(local.devcoopspawnmarkers == 7){
		local.rowNum = 1
		local.testorigin[0] -= 20
		local.testorigin[1] -= 80
		local.originBaseline = local.testorigin
		
		for(local.i=1;local.i<=8;local.i++){
			$("coopSMkr"+local.i) origin local.testorigin
			local.testorigin[0] += 40
			if(!(local.i % 2)){
				local.testorigin = local.originBaseline
				local.testorigin[1] += (40 * local.rowNum)		
				local.rowNum++
			}
		}
	}
}end



//[202] chrissstrahl - move player to each new marker and wait for him to move away
//=========================================================================
testmarkers:{
//=========================================================================
	if( self == NULL || self.health <= 0 || level.coopDevtestNewSpawn == 1){
		end
	}
	if(!($("coopSMkr"+local.i))){
		self iprint ( "TEST NEW SPAWNS - ERROR: No spawns found!" ) 1 NIL
		end
	}
	
	level.coopDevtestNewSpawn = 1
	
	
	
	self iprint ( "TEST NEW SPAWNS - MOVE AWAY TO CONTINUE!" ) 1 NIL
	self nodamage
	
	for(local.i=1;local.i<=8;local.i++){
		if(self.health <= 0 || self.dmteam == "spectator"){
			if(self){
				self takedamage
			}
			level.coopDevtestNewSpawn = 0
			end
		}

		local.vec = $("coopSMkr"+local.i).origin
		
		if(local.vec == NIL){
			self iprint ( "coop_spawn"+local.i+"origin was NIL!" ) 1 NIL
			continue
		}
		local.ang = $("coopSMkr"+local.i).angles
		
		self forcelegsstate STAND
		self tele local.vec
		self face local.ang
		
		while( self != NULL && self.health > 0 && vector_length( local.vec - self.origin) < 100 && local.i<8 && self.dmteam != "spectator"){
			waitframe
		}
		if(local.i<8){
			self iprint ( "TEST NEW SPAWN: "+local.i ) 1 NIL
			wait 1
		}
	}
	if(self){
		self iprint ( "TEST NEW SPAWN: Complete" ) 1 NIL
		self takedamage
	}
	level.coopDevtestNewSpawn = 0
}end

//=========================================================================
printmarkers local.markernames:{
//=========================================================================
	if(level.coopMarkersIndex==NIL){
		level.coopMarkersIndex=0
	}
	level.coopMarkersIndex++
	
	local.playerCleanName = waitthread coop_mod/player.scr::playerCleanName self.netname
	self iprint ( "Printed markers"+level.coopMarkersIndex+" locations into Server console for "+local.playerCleanName) 1 NIL
	println ( "Printed markers"+level.coopMarkersIndex+" locations into Server console for "+local.playerCleanName)
	
	//enable logging on server
	local.logfile = int(getcvar("logfile"))
	if(!local.logfile){
		setcvar ( "logfile 1" )
	}
	
	//activate logfile for dev client
	if( level.coop_dedicated &&  self ){
		self stufftext "logfile 1"
	}
	
	waitthread printtoserverandclient ("==HZM Coop Dev: printmarkers "+local.playerCleanName+" @ "+level.coop_mapname+" "+level.coopMarkersIndex) self
	
	for(local.i=1;local.i<9;local.i++){
		local.marker = $("coopSMkr"+local.i)
		if(local.marker){
			local.temporigin = ""
			local.origin = local.marker.origin
			local.angles = ( 0 0 0 )
			local.angles[1] = local.marker.angle
			for(local.j=0;local.j<3;local.j++){
				local.temporigin += " "
				local.temporigin += int(local.origin[local.j])
			}
			local.temporigin += " "
			local.origin = local.temporigin
			
			waitthread printtoserverandclient ("level.flags[coop_spawn"+local.i+"origin] = ("+local.origin+")") self
			waitthread printtoserverandclient ("level.flags[coop_spawn"+local.i+"angles] = ("+local.angles+")") self
			
		}
	}
	waitthread printtoserverandclient ("==end of markers") self
	waitframe
	if(!local.logfile){
		setcvar ( "logfile 0" )
	}
}end

//=========================================================================
dev_blink local.player local.rate:{
//=========================================================================
	if(self.flags["coopBlinking"] != NIL){ end }
	self.flags["coopBlinking"] = 1
	
	while(self && self.flags["coopBlinking"] && local.player && self istouching local.player ){
		if(!self){ end }
		self hide
		wait local.rate
		
		if(!self){ end }
		self show		
		wait (2 *local.rate)
	}
	if(self){ self.flags["coopBlinking"] = NIL }
}end

//creates a preview of how spawnspots would look at this clocation
//=========================================================================
spawnmarkers_spawn:{
//=========================================================================
	for(local.i=1;local.i<9;local.i++){
		local.marker = $("coopSMkr"+local.i)
		
		local.angles = "0 "
		local.angles += int(self.viewangles[1])
		local.angles += " 0"
		
		if(!local.marker){
			//spawn script_model model "models/items/Af_P_Lantern.tik" origin (local.origin) notsolid 1 targetname ("coopSMkr"+local.i) scale 3
			spawn script_model model "models/player/german_Scientist.tik" origin ( 0 0 -999 ) notsolid 1 targetname ("coopSMkr"+local.i) scale 1
		}
	}
}end

//creates a preview of how spawnspots would look at this clocation
//=========================================================================
spawnmarkers_remove:{
//=========================================================================
	for(local.i=1;local.i<9;local.i++){
		local.marker = $("coopSMkr"+local.i)
		if(local.marker){
			$("coopSMkr"+local.i) remove
		}
	}
}end
