//////////////////////////////////////////////
// VERSION 1.0 started by chrissstrahl on 2018.06.28
// CURRENT VERSION 2.02
//
// This contains the main functions for the HaZardModding Coop Mod for
// - Allied Assault
// - Breaktrough

//WARNING these files contain Adult commentary

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//					THIS IS VERY IMPORTANT - READ THIS
// - there are a few functions that need to be timed just right for the Mod to work
// - do not introduce any delay like wait or waitframe, in or before these functions are called
// - delay will make these functions no longer reliable
// - main, manageplayers
// - please consult chrissstrahl or smithy for followup questions
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//ALL THIS CODE HAS TO BE STARTED IN A SINGLE FRAME, NO DELAYS
//=========================================================================
main:{
//=========================================================================
	//[202] chrissstrahl - enable thread debug/printouts here - 0, NULL or NIL = OFF / every other value enables it
	//basename of var is always level.cMTE_coop_ then the actual filename of the coop mod scriptfile
	//is attached without extension, for coop_mod/main.scr that would be level.cMTE_coop_main
	//
	//Best way to use this is to use the specific var in the level script you want to debug
	//this way you won't get spammed on all the maps.
	/*
	level.cMTE_coop_aihandler = 0
	level.cMTE_coop_bt_playerTank = 0
	level.cMTE_coop_butler = 0
	level.cMTE_coop_custom_items = 0
	level.cMTE_coop_developer = 0
	level.cMTE_coop_events = 0
	level.cMTE_coop_eventssystem = 0	
	level.cMTE_coop_itemhandler = 0	
	level.cMTE_coop_loadout = 0
	level.cMTE_coop_main = 0
	level.cMTE_coop_maplist = 0
	level.cMTE_coop_mg42_hack = 0
	level.cMTE_coop_missioncomplete = 0
	level.cMTE_coop_mom_actions = 0
	level.cMTE_coop_player = 0
	level.cMTE_coop_replace = 0
	level.cMTE_coop_server = 0
	level.cMTE_coop_spawnlocations = 0
	level.cMTE_coop_strings = 0
	level.cMTE_coop_variables = 0
	level.cMTE_coop_vehiclehandler = 0
	level.cMTE_coop_weaponstate = 0
	*/
	
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/main->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//[200] Smithy - used for script load checks, also can be used in future scripts
	local.threadName = "coop_mod/main.scr::main" 

	//[202] chrissstrahl - Inizialize required game and level variable for the coop mod
	waitthread coop_mod/variables.scr::main
	
	//[200] chrissstrahl - restore default speed after automatic speed mapcheck
	if( int(getcvar("coop_dev")) == 1 || int(getcvar("developer")) > 0 ){ setcvar "timescale" 1 }

	//[200] chrissstrahl - moved here to get the real mapname - fixed it now
	if(level.script	== NIL){ level.script	= "maps/"+level.coop_mapname+".scr" }

	//SINGLEPLAYER//////////////////////////
	if( level.gametype == 0 ){
		thread spWaitForPlayer
		end
	}
	
	//[202] chrissstrahl - once coop_mod/variables.scr::main is iniziallized set up the server
	waitthread coop_mod/server.scr::main
	
	//chrissstrahl - create spawnpoints for coop
	waitthread coop_mod/spawnlocations.scr::main
	
	//chrissstrahl - handles spawning, respawning spectator, generic stuff each frame
	thread coop_mod/player.scr::manage

	//[200] Smithy - initialises the weapon loadout array for this level - moved from itemhandler.scr
	exec coop_mod/loadout.scr
	
	//[200] Smithy - disable weapons on select menu
	thread coop_mod/itemhandler.scr::disableAllWeaponsOnMenu
	
	//chrissstrahl - set coop mod specific mom file
	//[202] chrissstrahl - disabled my mom, there was no need for this
	//thread mom/mom.scr::setup "coop_mod/mom_actions.scr" 2 "coop_mom"
	
	//[200] Smithy - initialise all events we need
	thread coop_mod/events.scr::initialiseEvents
	
	//[200] Smithy - used by waitForMainScript to check if main has loaded
	level.coop_mainScriptLoaded = game.true

	//[200] Smithy - created funcs for events
	if (thread coop_mod/eventsystem.scr::isEventActive "mainScriptLoaded"){									
		println "(" local.threadName "): ***** Loaded *****. Continuing " level.coop_waitingForMainThreads " waiting threads at " level.time "..." //better reporting
		//[200] Smithy - used by itemhandler and aihandler (+ future scripts) to notify that main has been loaded
		thread coop_mod/eventsystem.scr::doEvent "mainScriptLoaded" 			
	}
}end

//[200] chrissstrahl - have a seperate handle for singleplayer
//=========================================================================
spWaitForPlayer:{
//=========================================================================
	level waittill spawn
	level.coop_playerReady = 1
	//[200] chrissstrahl - set variables
	$player.flags["coop_isHost"] = 1
}end

//[200] chrissstrahl - this autospawns the hosting player
//this is meant to be used for debugging/testing all maps
//=========================================================================
autoSpawnHost:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/autoSpawnHost->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handlingif(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/->"+level.cMTE+"" ) //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(level.coop_dedicated != 0){ end }

	local.player = getentbyentnum( 0 )
	while( local.player == NULL ){
		waitframe
	}

	local.player iprint "You are being auto spawned for testing!!!" 1
	local.player stufftext ( "primarydmweapon rifle" )

	wait 0.1
	if( local.player == NULL ){ end }

	local.player stufftext ( "popmenu 0" )
	local.player stufftext ( "+attackprimary" )
	waitframe

	if(local.player == NULL){ end }

	local.player stufftext ( "-attackprimary" )
}end

//forces player into allies team
//=========================================================================
forceTeam local.player:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/forceTeam->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if( local.player == NIL || local.player == NULL ){ end }

	//local.player.flags["coop_team"] = local.player.dmteam //[200] Smithy - we don't need to track if we know allies is what will make us active
	waitthread resetSpawn local.player
	
	//[202] chrissstrahl - reset last selected spawnlocation
	local.player.flags["coop_spawnlocAlt"] = NIL

	thread global/throbtext.scr::throbtext "Only allies are allowed in Coop!" 5

	wait 1 //[200] Smithy - fixes bug where allies still appear as axis

	if (local.player && local.player.dmteam == "axis"){  //[200] Smithy - check now we have a wait before following commands
		local.switchDelay = getcvar "g_teamswitchdelay"  //[200] Smithy - stop switch delay intefering 
		setcvar "g_teamswitchdelay" "0"
		local.player join_team ( "allies" )
		setcvar "g_teamswitchdelay" local.switchDelay
		//wait game.ms
		//if (!local.player){ end }
		local.player primarydmweapon "rifle"
		local.player pickweapon
		local.player stufftext ( "popmenu 0" )
	}
}end

//makes player respawn at predefined spawn location, rather than the last pos player was alive
//=========================================================================
resetSpawn local.player:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/resetSpawn->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.player.flags["coop_respawnOrigin"] = ( 0 0 0 )
	local.player.flags["coop_respawnAngle"] = 0
	local.player.flags["coop_respawning"] = FALSE
}end

//[200] Smithy
//Is called from events.scr every time a player spawners.
//we can use this to efficiently replace any spawn specific code, 
//e.g. triggers that check for active players.
//along with this method + NightFall events we can decommission the main loop.
//I will be slowly moving stuff here from main loop...
//(internal use only)
//=========================================================================
playerSpawnEvent:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playerSpawnEvent->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//KEEP TRACK /////////////////////////////////////////////
	//of when any player was active for the first time
	if(level.coop_gameStartedAt == NIL){
		level.coop_gameStartedAt = level.time
	}

	local.player = self
	thread coop_mod/player.scr::manageAliveSpawning local.player
}end

//[200] Smithy
//called every time a player dies. this is called from events.scr,
//which in turn is called from coop_mod/player_torso on KILLED state.
//I added an extra layer and put it here as it is more intuitive and
//easier to find.
//When we transition to NightFall events then they will be housed 
//with events.scr too.
//=========================================================================
playerDeathEvent:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playerDeathEvent->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.player = self
	thread coop_mod/player.scr::manageDead local.player
}end

//[200] Smithy
//this is a stub. not called from anywhere yet. Will be called via events.scr
//when we set up a NightFall event for it. 
//Status: Waiting for listen server support in NightFall
//=========================================================================
playerTeamChangeEvent:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playerTeamChangeEvent->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.player = self
}end

//[200] Smithy
//[202] chrissstrahl - return if forcing was nessary
//=========================================================================
forceValidTeam:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/forceValidTeam->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.player = self
	if (local.player.dmteam == "axis"){
		thread forceTeam local.player
		end 1
	}
}end 0

//[200] Smithy - forces a player to join allies and skip selection process
//=========================================================================
skipTeamAndWeaponSelect local.player:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/skipTeamAndWeaponSelect->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//[201] Tiredsstrahl - Fix player being spawned in LMS when he shouldn't
	//EXIT on NIL
	//EXIT on NULL
	//EXIT if player is flagged as totally dead in LMS
	//if(local.player == NIL || local.player == NULL || thread lmsGetRemainingLives local.player < 1){
	if(local.player == NIL || local.player == NULL || local.player.flags["coop_lmsForcedInSpectator"] == 1){
		wait game.ms
		end
	}
	//END [201]

	//[200] Smithy - put here to stop spam that prevents players typing/using menu
	local.switchDelay = getcvar "g_teamswitchdelay"  //[200] Smithy - stop switch delay intefering 
	setcvar "g_teamswitchdelay" "0"	
	local.player join_team "allies"
	setcvar "g_teamswitchdelay" local.switchDelay

	local.player stufftext "popmenu 0"		//close the team menu
	local.player primarydmweapon "rifle" 	//give him a random primary gun
	local.player pickweapon 				//make him pick it	
	local.player stufftext "popmenu 0"		//close the weapons menu
	local.player stopfire "dual" 			//stop weapon fire bug when clicking several times
	wait game.ms
	
	//[201] Tiredsstrahl - Make sure player did not disconnect
	if(local.player){ //[202] chrissstrahl - now also checks for NIL
		local.player stopfire "dual"
	}
	//END [201]
}end

//[200] Smithy - own func for giving player their health
//=========================================================================
playerHealth:
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playerHealth->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.player = self

	local.coop_cvarHealth = int(getCvar("coop_health"))

	if (local.coop_cvarHealth == 0){
		level.coop_health = 750
	}else{
		level.coop_health = local.coop_cvarHealth
	}

	local.player health level.coop_health //this does both max_health and healthonly for you
end				

//[200] chrissstrahl - this is called if the number of player has changed
//::managePlayers is waiting for this thread
//=========================================================================
playerCountChanged local.prevPlayerCount local.playerCount:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playerCountChanged->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//[200] chrissstrahl - if no player left on server restart mission
	if(local.playerCount == 0){
		wait 1
		waitthread restartMap
		end
	}

	//[202][hotfix] Smithy - check if player 0 has left the game. if so, do a reconnect on the player that has been around the longest
	thread game.player::checkClientZero
	
	//[200] chrissstrahl - call Smithys ai handler to update
	exec coop_mod/aihandler.scr::updateEnemyTeamDifficulty
}end

//chrissstrahl - prints a info to player hud, only each 3 sec
//bold set to 1 prints it in bold
//strictTime set to 1 does allways wait 3 sec before next message regardless if the message text has changed
//=========================================================================
printInfo local.player local.message local.bold local.strictTime:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/printInfo->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(local.player == NULL || local.message.size < 1){ end }

	//keep timelimit only if same message
	if(local.strictTime == NIL || local.strictTime != 1 ) {
		if(	local.player.flags["coop_lastInfoPrintText"] != NIL &&
			local.message == local.player.flags["coop_lastInfoPrintText"] &&
			level.time < int(local.player.flags["coop_lastInfoPrint"] + 3))
		{
			end
		}
	}
	//keep strict time limit, exit if last msg was send under 3 sec
	else if(local.player.flags["coop_lastInfoPrint"] != NIL && level.time < (int(local.player.flags["coop_lastInfoPrint"])+3)){
		end
	}

	if(local.bold == NIL){
		local.bold = 0
	}
	local.player iprint local.message local.bold
	local.player.flags["coop_lastInfoPrint"] = level.time
	local.player.flags["coop_lastInfoPrintText"] = local.message
}end

//chrissstrahl - this fixes the facing not working most of the time, can't tell what the exact cause might be
//=========================================================================
playerFace local.direction:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playerFace->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	for(local.i=0;local.i<4;local.i++){
		waitframe
		if(self == NULL){
			break
		}
		self face local.direction
	}
}end

//warps all players to a specific coord
//- if local.origin is NIL players will be warped to their spawnlocations
//- if local.setSpawn set to 1 it will set this location as new spawn for all players
//
//this might need some attention, as it does not handle vehicle players - see func below: playerPlaceAtSpawn
//=========================================================================
playersWarpto local.origin local.angle local.setSpawn:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playersWarpto->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(local.origin == NIL){
		for (local.pl = 1;local.pl <= $player.size;local.pl++){
			local.player =  $player[local.pl]
			thread playerPlaceAtSpawn local.pl
		}
	}
	else if(local.setSpawn == 1){
		for( local.i = 1;local.i<=8;local.i++){
			if(local.angle==NIL){
				local.angle = ( 0 1 0 )
			}
			level.flags["coop_spawn"+local.i+"angles"] = ( local.angle )
			level.flags["coop_spawn"+local.i+"origin"] = ( local.origin )
		}
	}

	for (local.i = 1;local.i <= $player.size;local.i++){
		local.player =  $player[local.i]
		//make sure that local.origin is set, grab origin from spawn loc
		if(local.origin == NIL){
			local.origin = level.flags["coop_spawn"+local.i+"origin"]
		}
		//elevate a little that we can use dropfloor, just in case...
		local.player origin (local.origin+(0 0 1))
		local.player droptofloor
		//clear respawn coord
		thread resetSpawn local.player

		//need to call this delayed or it will not work most of the time in mp
		if(local.angle != NIL){
			local.player thread playerFace local.angle
		}

		//make sure players don't get stuck even if there are no valid spawns
		thread playerMakeSolidAsap local.i
	}
}end

//=========================================================================
playerPlaceAtSpawn local.i:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playerPlaceAtSpawn->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//[200] chrissstrahl - if we are given a entity instead of a number, deal with it
	//detecting a single player entity as 0
	//detecting a interger as 1 or
	if(local.i == NIL){ end }
	
	local.varType = waitthread returnVarType local.i NIL "main::playerPlaceAtSpawn"
	//entity - fine grab directly
	if(local.varType == 2){
		local.player = local.i
		//[202] chrissstrahl - this fixes issues when using entity instead of number as parameter to call this func
		local.i = thread getPlayerId local.player
	}
	//int - grab by player number
	else if(local.varType == 4){
		local.player = $player[int(string(local.i))] //just to be sure convert to string then int, a player in a var can also be returned as a number, this is why we make sure to convert it over
	}
	//error out, it is better than never finding out whats wrong
	else{
		local.typename = waitthread returnVarTypename local.varType
		error ("coop_mod/main.scr::playerPlaceAtSpawn - does not support var type: "+local.typename) 1000
	}

	if!(local.player){ end }
	
	//[202] chrissstrahl - this allowes a player to spawn at a different spawnlocation - used for player.scr::preventSpawnStuck
	if(local.player.flags["coop_spawnlocAltActive"]){
		local.i = local.player.flags["coop_spawnlocAlt"]
		local.player.flags["coop_spawnlocAltActive"] = NIL
		
	}

	if( local.player.flags["coop_playerTankExit"] != NIL && $coop_tankExit != NULL){
		local.player origin ( $coop_tankExit.origin + (0 0 150) )
		local.player droptofloor
		if(local.player.flags["coop_isActive"] == 1){
			local.player.flags["coop_playerTankExit"] = NIL
		}
	}
	else if(level.flags["coop_spawn"+local.i+"origin"] != NIL ){
		if( (local.player.flags["coop_lastRespawn"] + 1.5) < level.time){
			//[202] chrissstrahl - remember last spawn location
			local.spawnNewOrigin = level.flags["coop_spawn"+local.i+"origin"]
			local.player.flags["coop_spawnlocPreviouse"] = local.spawnNewOrigin
			local.player origin	local.spawnNewOrigin

			if(level.flags["coop_spawn"+local.i+"angles"] != NIL){
				//need to call this delayed or it will not work most of the time in mp
				local.player thread playerFace level.flags["coop_spawn"+local.i+"angles"]
			}
			//if(level.coop_spawnForceState != NIL){
				//local.player forcelegsstate level.coop_spawnForceState
			//}
		}
	}
	//make sure players don't get stuck even if there are no valid spawns
	thread playerMakeSolidAsap local.player
}end

//checks if objects are touching
//=========================================================================
playerMakeSolidAsapCheckTouching local.player local.object local.hasHealth:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playerMakeSolidAsapCheckTouching->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if( local.object && local.player isTouching local.object ){
		if( local.hasHealth && local.object.health <= 0 ){
			end
		}
		println ("playerMakeSolidAsapCheckTouching -> a player is touching: "+local.object)
		goto playerMakeSolidAsap_touching
	}
}end

//makes a player solid as soon as it is saftly possible
//checking for other players and certain general entities
//=========================================================================
playerMakeSolidAsap local.i:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playerMakeSolidAsap->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(!local.i){ end }

	local.player = NULL

	//if we are given a entity instead of a number, deal with it
	//detecting a single player entity as 0
	//detecting a interger as 1 or
	local.varType = waitthread returnVarType local.i NIL "main::playerMakeSolidAsap"
	//entity - fine grab directly
	if(local.varType == 2){
		local.player = local.i
		//[202] chrissstrahl - this fixes issues when using entity instead of number as parameter to call this func
		local.i = thread getPlayerId local.player
	}
	//int - grab by player number
	else if(local.varType == 4){
		local.player = $player[int(string(local.i))] //just to be sure convert to string then int, a player in a var can also be returned as a number, this is why we make sure to convert it over
	}
	//error out, it is better than never finding out whats wrong
	else{
		local.typename = waitthread returnVarTypename(local.varType)
		error ( "coop_mod/main.scr::playerMakeSolidAsap - does not support var type: "+local.typename ) 1000
	}

	//run only once per player
	if(local.player.flags["coop_makesolid"] != NIL){ end }
	
	local.player.flags["coop_makesolid"] = 1
	
	while( local.player && local.player.flags["coop_makesolid"] != NIL ){
		local.touch = 0
	
		if(local.player.health <= 0){
			local.player.flags["coop_makesolid"] = NIL
			end
		}
		if(level.gametype != 0){
			if(local.player.dmteam == "spectator" || local.player.flags["coop_isActive"] != 1 ){
				local.player.flags["coop_makesolid"] = NIL
				end
			}
		}

		//[200] chrissstrahl - added notsolid here just to be sure the player is notsolid from the get go
		local.player notsolid
		
		//don't do player checks in sp
		if( level.gametype == 0){
			goto playerMakeSolidAsap_spCheck
		}
		
		// CHECK PLAYER AGAINST PLAYER
		for (local.iOther = 1;local.iOther <= $player.size;local.iOther++){
			local.otherPlayer =  $player[local.iOther]
				
			//don't check the player against him self
			//[202] chrissstrahl - restored spectator check to old standard because it was causing a bug on spawn!
			if(local.player == local.otherPlayer || local.otherPlayer.dmteam == "spectator" || local.otherPlayer.health <= 0 ){ //local.otherPlayer.flags["coop_isActive"] != 1
				continue
			}
			
			//check if they are stuck inside each other
			if(local.player isTouching local.otherPlayer){
				local.otherPlayer notsolid
				thread playerMakeSolidAsap local.iOther
				local.touch = 1
			}
		}
		//check here if any player was touched
		//we needed to have this check against all players
		//so players get their own check to prevent issues
		if(local.touch){
			goto playerMakeSolidAsap_touching
		}
		
		//checks that also are done in singeplayer start here
		playerMakeSolidAsap_spCheck:
		
		//check friendlies
		waitthread playerMakeSolidAsapCheckTouching local.player level.friendly1 1
		waitthread playerMakeSolidAsapCheckTouching local.player level.friendly2 1
		waitthread playerMakeSolidAsapCheckTouching local.player level.friendly3 1
		waitthread playerMakeSolidAsapCheckTouching local.player level.friendly4 1
		waitthread playerMakeSolidAsapCheckTouching local.player level.friendly5 1
		waitthread playerMakeSolidAsapCheckTouching local.player level.friendly6 1
		
		//check map specific
		if(level.coop_levelObstacle[level.coop_mapname]){
			for(local.i=1;local.i <= level.coop_levelObstacle[level.coop_mapname].size;local.i++){
				local.object = level.coop_levelObstacle[level.coop_mapname][local.i][1]
				waitthread playerMakeSolidAsapCheckTouching local.player local.object
			}
		}
		
		//check general
		for(local.i=1;local.i <= level.coop_levelObstacle["general"].size;local.i++){
			local.object = level.coop_levelObstacle["general"][local.i][1]
			waitthread playerMakeSolidAsapCheckTouching local.player local.object
		}
		
		//this code is only executed if player did not touch anything relevant
		local.player.flags["coop_makesolid"] = NIL
		local.player solid
		end
		
		//code that is executed if objects are touching
		playerMakeSolidAsap_touching:
		
		//println("playerMakeSolidAsap loop")
		waitframe
	}
}end

//gives all items to the player
//=========================================================================
itemGetAll:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/itemGetAll->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(level.coop_playerItem1 != NIL ){	self item level.coop_playerItem1 }
	if(level.coop_playerItem2 != NIL ){	self item level.coop_playerItem2 }
	if(level.coop_playerItem3 != NIL ){	self item level.coop_playerItem3 }
	if(level.coop_playerItem4 != NIL ){	self item level.coop_playerItem4 }
	if(level.coop_playerItem5 != NIL ){	self item level.coop_playerItem5 }
	if(level.coop_playerItem6 != NIL ){	self item level.coop_playerItem6 }
}end

//=========================================================================
//=========================================================================
//=========================================================================
//=========================================================================
//========================================================== FRIENDLY STUFF
//=========================================================================
//=========================================================================
//=========================================================================
//=========================================================================

//=========================================================================
friendlyPlayerOrigin:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/friendlyPlayerOrigin->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
//return the origin of player that is currently set as ai follow target
	if( level.coop_player != NIL && level.coop_player != NULL ){ //[201] chrissstrahl - added NIL check
		end level.coop_player.origin
	}
}end (0 0 0)

//set destination for ai
//=========================================================================
destination:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/destination->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(self == NULL){ end }

	//try to follow current follow-player
	self.destination = level.coop_player
	self.beacon = "Player" //[202][hotfix] Smithy

	thread managePlayerToFollow
}end

//set tether for ai
//=========================================================================
tether:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/tether->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(self == NULL){ end }

	//try to leash to current follow-player
	self tether level.coop_player

	thread managePlayerToFollow
}end

//set tether for ai
//=========================================================================
managePlayerToFollow:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/managePlayerToFollow->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(level.coop_managePlayerToFollow != NIL){ end }

	level.coop_managePlayerToFollow = 1
	local.grabNewPlayer = 1

	local.tries = 0
	local.triesMax = 30

	//run this loop until we decide to cancel it (probably never)
	while( level.coop_managePlayerToFollow ){

		//if everything is ok, wait a moment then try again
		if(level.coop_player != NULL && local.grabNewPlayer != 1){
			//[200] chrissstrahl - added handle for singleplayer
			if(level.gametype != 0){
				if(	level.coop_player.dmteam == "spectator" ||
					level.coop_player.health <= 0 ||
					level.coop_player.flags["coop_isActive"] != 1)
				{
					local.tries++
				}
			}else if(level.coop_player.health <= 0){
				end
			}

			//if max tries exceeded, find new player
			if(level.coop_player == NULL || local.tries >= local.triesMax){
				local.grabNewPlayer = 1
			}

			wait 1
			continue
		}

		//[200] chrissstrahl - note we can only test this once we have dedicated servers
		//pause if there is no player
		while!( $player ){
			local.grabNewPlayer = 1
			wait 2
		}

		//try to find next best player to follow
		//iprintlnbold_noloc ( "find player to follow" ) //chrissstrahl
		local.grabNewPlayer = 0
		local.tries = 0
		waitthread friendlyFindPlayer //[201] chrissstrahl - fix typo
		waitframe
	}
}end

//=========================================================================
friendlyFindPlayer:{ //[201] chrissstrahl - fix typo
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/friendlyFindPlayer->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//[200] chrissstrahl - make sure this works in sp as well
	//thanks to DoubleKill for reporting this issue
	if(level.gametype == 0){
		level.coop_player = $player
		end
	}
	
	//find a valid player to follow, this is used to direct the ai to a player to follow
	for (local.i = 1;local.i <= $player.size;local.i++){
		local.player =  $player[local.i]
		if(local.player.health > 0 && local.player.dmteam != "spectator" && local.player.flags["coop_isActive"] == 1){
			level.coop_player = local.player
			//iprintlnbold_noloc ( "player found..." + local.i + "::" + level.coop_player )
			end
		}
	}
	level.coop_player = NULL
}end

//[202] Smithy - tidied and simplified
//=========================================================================
isPlayerActive local.player:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/isPlayerActive->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
//checks if a player is valid
	if(level.gametype == 0){
		end (isAlive $player) //[202] Smithy - simpler
	}
	
	if (local.player == NIL){
		error ( "coop_mod/main.scr::isPlayerActive - parameter 1 was NIL, needs to be player" ) 1000
		end 0		
	}
	
}end (isAlive local.player && !local.player.isSpectator && local.player.flags["coop_isActive"]) //[202] Smithy - simpler, plus checks for temp and active spectators

//PLEASE NOTE! THIS FUNCTION HAS A INTENTIONAL 1 FRAME DELAY!
//=========================================================================
startThread local.script local.entity:{ //[200] chrissstrahl - add optional caller (the idea is to allow a entity to be passed)
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/startThread->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.trigger = spawn trigger_once setthread local.script
	waitframe

	//[200] chrissstrahl - optional caller
	if(local.entity == NIL || local.entity == NULL || local.entity.size > 1){
		local.entity = $world
	}

	if( local.trigger != NULL ){
		if($world == NULL){error ( "coop_mod/main.scr::startThread - NO $world FOUND - FATAL ERROR" ) 1000}
		local.trigger doActivate local.entity
	}
}end

//=========================================================================
getPlayerId local.player:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/getPlayerId->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
//returns $player entity number id like $player[3] returns 3
	if(level.gametype == 0){ end 1 }

	if(local.player){ //[202] chrissstrahl - now also checks for NIL
		for (local.i = 1;local.i <= $player.size;local.i++){
			if( $player[local.i] == local.player ){
				end local.i
			}
		}
	}
}end NIL

//checks if a string contains the given text
//[202] chrissstrahl - returning now starting position of where string was found if instructed to do so
//=========================================================================
containsText local.source local.text local.giveStartPos:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/containsText->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(local.source == NIL || local.text == NIL || local.source.size < local.text.size){ end 0 }

	local.index = 0
	local.matchStartsAt = 0 //[202]
	for(local.i=0;local.i<local.source.size;local.i++){
		//part of match found
		if(local.source[local.i] == local.text[local.index]){
			local.index++
			if(local.matchStartsAt == 0){ //[202]
				local.matchStartsAt = local.i
			}
			//complete match found
			if(local.index == local.text.size){
				if(local.giveStartPos){ //[202]
					end local.matchStartsAt
				}
				end 1
			}
		}else{
			local.index = 0
			local.matchStartsAt = 0 //[202]
		}
	}
}end 0

//removes the given string from the string
//[202] chrissstrahl upgraded to handle a entire word
//[202] chrissstrahl upgraded to allow specification on how many matches are to be filtred
//=========================================================================
cleanText local.source local.text local.maxremovals:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/cleanText->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(	local.source == NIL ||
		local.text == NIL ||
		local.source.size < local.text.size ||
		!waitthread containsText local.source local.text
	
	){ end local.source }
	local.match=0
	local.newString = ""
	if(local.maxremovals == NIL){
		local.maxremovals = 999999
	}
	
	local.filtered = ""
	local.searchTextIndex=0
	for(local.i=0;local.i<local.source.size;local.i++){
		//matching char
		if(local.source[local.i] == local.text[local.searchTextIndex] && local.match < local.maxremovals){
			local.filtered += local.source[local.i]
			//println("cleanText char match:"+local.filtered+":atindex:"+local.searchTextIndex)
			//string match complete
			if(local.filtered == local.text){
				//println("cleanText full match:"+local.filtered)				
				local.filtered = ""
				local.searchTextIndex=0
				local.match++
			}else{
				local.searchTextIndex++	
			}
		}else{
		//no matching char
			//println("cleanText text!=")
			local.newString += local.filtered
			local.newString += local.source[local.i]
			local.filtered = ""
			local.searchTextIndex=0
		}
	}
}end local.newString

//return type of variable
//performs a series of checks to determine the variable type ?
//type: 0-NIL/NULL, 1-string,2-entity,3-vector,4-int/float,5-entityarray
//-1 could not detect type
//
//[202] chrissstrahl - added feature to differ between entity and entity array via parameter, added NULL check
//
//HIRACY:
//1. ENTITY CHECK (NO ARRAY)
//2. VECTOR CHECK -> CHAR>1 STRING CHECK -> INT/FLOAT CHECK -> DEFAULT TO STRING
//3. DEFAULT TO STRING
//4. NO MATCHING TYPE (-1 could not detect type)
//=========================================================================
returnVarType local.var local.differArray local.threadName:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/returnVarType->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(local.var == NIL ){
		println("main.scr::returnVarType was NIL ["+string(local.var)+"] -> "+string(local.threadName)+"")
		end 0
	}
	if(local.var == NULL ){
		println("main.scr::returnVarType was NULL ["+string(local.var)+"] -> "+string(local.threadName)+"")
		end 0
	}

	local.stringified = string(local.var)
	local.stringifiedSize = local.stringified.size

//chrissstrahl - debug activated
//println("size   ("+local.var.size+")")
//println("string ("+local.stringified+")")

//var is of type entity(single one) or string
	if(local.var.size == 0){
	//it can be either a empty string or a entity
		if(local.stringifiedSize == 0 ){ end 1 }
		end 2
	}
//var is type of integer, entity(array) or vector or singleletter string
	else if(local.var.size == 1){
		//[202] chrissstrahl - try to catch strange error we are having
		if(local.stringifiedSize == 0 && local.stringified == ""){
			//println("main.scr::returnVarType unknown var at unexpected place")
			//[202] Smithy - e.g. this can be ScriptModel or ScriptSlave
			//yes, classname property assumes it is an entity
			//local.class = local.var.classname 
			//if (local.class != NIL){
				end 2
			//}
			//end -1
		}		
		local.firstChar = string(local.stringified[0])
	//assume it is a vector if it is in brackets
		if( local.stringified[0] == "(" && local.stringified[local.stringifiedSize-1] == ")" ){
			end 3
		}
	//note: can NOT detect entities with a targetname < 2 chars
		if(local.stringifiedSize > 1){
		//entity targetnames never start with a number or a colon not a number will be 0 when converted
			if(	int(local.firstChar) == 0 && int(local.stringified) == 0 && local.stringified != "0.000" && local.stringified[0] != "."){
				//[202] chrissstrahl - differ between entity and entity array if wanted
				if(local.differArray){ //make sure it does not accept a word-string as true
					end 5
				}else{
					end 2
				}
			}

			//[200] chrissstrahl - allow this thread to be executed within 1 frame
			//no waits anywhere allow for greater usage flexibility
			local.thisIsAFloat = 0
			if( local.stringified == "0.000" ){
				local.thisIsAFloat = 1
			}else{
				if( float(local.stringified) == 0 ){
					local.thisIsAFloat = 0
				}
				else{
					local.dotAt = -1
					local.afterDot = 0
					for(local.i=0;local.i<local.stringified.size;local.i++){
						if(local.afterDot != -1){
							local.afterDot++
						}
						if(local.stringified[local.i] == "."){
							local.dotAt = local.i
							local.afterDot = 0
						}
					}
					if(local.afterDot == 3){
						local.thisIsAFloat = 1
					}
				}
			}
			if( local.thisIsAFloat == 1 || int(local.stringified) != 0){
				end 4
			}
		}else{
			if(int(local.stringified) != 0 || local.stringified == "0" || local.stringified != "0.000"){
				end 4
			}
		}
	//fallback to string
		end 1
	}
//must be a string
	else{
		if(local.stringifiedSize == 0 && local.stringified == ""){
			//[202] Smithy - e.g. this can be ScriptModel or ScriptSlave
			//yes, classname property assumes it is an entity
			//local.class = local.var.classname 
			//if (local.class != NIL){
				end 2
			//}
			//end -1
		}	
		end 1
	}
}end -1

//returns associated type name of type number
//=========================================================================
returnVarTypename local.var:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/returnVarTypename->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(local.var == 1){ end "String" }
	if(local.var == 2){ end "Entity" }
	if(local.var == 3){ end "Vector" }
	if(local.var == 4){ end "Int/Float" }
	//[202] chrissstrahl - updated typenames
	if(local.var == 5){ end "Entity Array" }
}end "Unknown"

//check if it is a float, game makes sure float always has 3 digits after the dot
//=========================================================================
isFloat local.var:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/isFloat->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.stringified = string(local.var)
	if( local.stringified == "0.000" ){ end 1 }
	if( float(local.stringified) == 0 ){ end 0 }

	local.dotAt = -1
	local.afterDot = 0
	for(local.i=0;local.i<local.stringified.size;local.i++){
		if(local.afterDot != -1){
			local.afterDot++
		}
		if(local.stringified[local.i] == "."){
			local.dotAt = local.i
			local.afterDot = 0
		}
	}

	if(local.afterDot == 3){ end 1 }
}end 0

//[200] chrissstrahl - text to print if developer needs to be activated
//=========================================================================
checkCoopDeveloper local.text:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/checkCoopDeveloper->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(int(getcvar("coop_dev")) == 1){ end 0 }
	self iprint (local.text+" is not allowed, cvar coop_dev needs to be 1") 1
}end 1

//[200] chrissstrahl - (new) glue player to object coop handle
//[200] Smithy - uses entnum for glue spots now
//=========================================================================
playerGlue local.player local.spawn local.hide:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/playerGlue->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if (!level.coop_playerGlue){ end }
	
	if(!level.coop_playerGlueIndividual){
		local.entity = level.coop_glueTo
	}else{
		local.entity = waitthread getGlueEntity local.player					
	}

	//[200] chrissstrahl - added forcelegsstate to avoid:
	//ERROR: Stopping due to possible infinite leg state loop //e1l3 entering rowboat at level start
	//local.player forcelegsstate "STAND"
	local.player resetstate //[200] Smithy - nicer than forcing a state, also may stop torso state errors as well as leg state

	if(!local.entity){
		println "(coop_mod/main.scr::playerGlue): *ERROR* - local.entity is " local.entity " for " local.player local.player.entnum
	}else{					
		if(level.coop_glueAngle != NIL){
			local.player glue local.entity level.coop_glueAngle
		}else{
			local.player glue local.entity
		}	

		if(!level.coop_playerGlueIndividual){
			local.player notsolid
			local.player physics_off
			if (local.hide){
				local.player hide
			}			
		}
	}
}end

//[200] Smithy - grab his glueTo entity
//as previous spots were numbered for array index, check this and 
//provide an offset. but also allow entnum number system for any future
//glue spots. 
//=========================================================================
getGlueEntity local.player:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/getGlueEntity->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if (!$(level.coop_glueTo + "0")){
		local.offset = 1 //array index start
	}else{
		local.offset = 0 //entnum start
	}
}end($(level.coop_glueTo + (local.player.entnum + local.offset)))

//[201] chrissstrahl - changed function name to fix typo
//[200] Chrissstrahl - used to to check if a player should be for into spectator
//=========================================================================
lmsGetRemainingLives local.player:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/lmsGetRemainingLives->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(local.player == NULL){ end 0 }

	//grab values
	local.lmsLives = level.coop_lmsLives //[201] chrissstrahl - fixed typo
	local.deaths = local.player.flags["coop_deaths"]

	//set new value
	if(local.deaths == NIL){
		local.deaths = 0
		local.player.flags["coop_deaths"] = local.deaths		
	}
	
	//check if player is out - if value is 0 we assume LMS if OFF
	if(local.lmsLives > 0){
		if(local.deaths >= local.lmsLives){
			local.remaining = (local.lmsLives - local.deaths)
			if(local.remaining < 0){
				local.remaining = 0
			}
			end local.remaining
		}
	}
}end 1

//[200] Chrissstrahl - used to force a player into spectator
//=========================================================================
lmsForceSpectatorHandle local.player:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/lmsForceSpectatorHandle->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(local.player.flags["lmsForceSpectatorHandleActive"] != NIL){ end 0 }

	while(local.player){ //[202] chrissstrahl - now also checks for NIL
		//check if player should be forced in spec
		if( thread lmsGetRemainingLives local.player < 1 ){ //[201] chrissstrahl - fixed typo
			local.player.flags["lmsForceSpectatorHandleActive"] = 1

			//check if player already is in spec, if not force
			if(local.player.dmteam != "spectator"){
				if(local.player.health == 0){
					local.player hide
				}
				local.player.flags["coop_lmsForcedInSpectator"] = 1
				local.player spectator
				
				//[201] chrissstrahl - make sure to clear all flags to prevent ongoing scripts to reinstate player
				//need probaly to sort out which ones are crucial
				//i know this stuff is mostly set in the next frame but that is one frame to late, thias is causing strange handling
				local.player.flags["coop_respawning"] = FALSE //prevent further handling in parent func
				local.player.flags["coop_iAmTruelyActive"] = 0 //prevent further handling in critical funcs
				
				//[201] chrissstrahl - inform player that he is out
				local.player iprint ( "You have 0 lives left - LastManStanding is active!" ) 1				

				//[200] chrissstrahl - fail mission if all players are dead
				local.numActivePlayers = 0
				for (local.i = 1;local.i <= $player.size;local.i++){
					local.player = $player[local.i]
					if(local.player.flags["coop_lmsForcedInSpectator"] != 1 && local.player.dmteam != "spectator"){
						local.numActivePlayers++
					}
				}
				if(local.numActivePlayers == 0){
					iprintlnbold_noloc("--")
					iprintlnbold_noloc("LMS failed all players are dead or inactive.")
					iprintlnbold_noloc("--")
					thread coop_mod/replace.scr::missionfailed
					end 1
				}			
			}
		}
		else{
			//if previously forced auto rejoin
			if(local.player.flags["coop_lmsForcedInSpectator"] == 1){
				local.player iprint "You are allowed back in the game!" 0
				local.player join_team ( "allies" )
			}
			local.player.flags["coop_lmsForcedInSpectator"] = NIL
			local.player.flags["lmsForceSpectatorHandleActive"] = NIL
			end 0
		}
		waitframe
	}
}end 1

/* [202] chrissstrahl - THIS WAS MOVED TO player.scr::manage
- reason 1: this function is only called there
- reason 2: We need to reduce a bit the thread calls to see if we can fix a issue we have, that sometimes no more threads are being created/executed
//[201] chrissstrahl - changed function name to fix typo
//[200] Chrissstrahl - check if LMS life count has changed
//=========================================================================
lmsCheckLives local.prevPlayerCount local.playerCount:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/lmsCheckLives->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
//[200] chrissstrahl - LMS - check if new players should be allowed to join
	local.prevLmsLives = level.coop_lmsLives //[201] chrissstrahl - fixed typo
	level.coop_lmsLives = int(getcvar("coop_lmsLives")) //[201] chrissstrahl - cvar from coop_lmsLifes to coop_lmsLives
	if(level.coop_lmsLives <= 0 ){ //[201] chrissstrahl - fixed typo
		level.coop_lmsLives = 0
		level.coop_lmsAllowJoin = 1

		if(local.prevLmsLives != 0){
			iprintlnbold_noloc("COOP: LMS inactive - Joining allowed")
		}
	}else{
		//prevent players from reconnecting and starting over
		//effects also players that connect for the first time (we can't detect that)
		if(local.prevPlayerCount > local.playerCount){
			local.timePassed = 0
			if(level.coop_gameStartedAt != NIL){
				local.timePassed = (level.time - level.coop_gameStartedAt)
			}else{
				local.timePassed = 0
			}

			if(local.timePassed > 30){
				iprintlnbold_noloc("COOP: LMS active - No late joining")
				level.coop_lmsAllowJoin = 0
			}
		}
	}
}end
*/

//[200] Smithy - changeGameType hack
//we use this whenever we want to trick game into thinking this is SP
//it lets us do disguises, sound callbacks, and other stuff
//Only one instance of this func can be run at any given time to prevent
//conflicts. as such, always use waitthread when calling it.
//Requires extra debug info for obvious reasons...
//=========================================================================
changeGameType local.gType local.wait:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/changeGameType->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if (level.gametype == 0){ end }

	local.threadName 		= "coop_mod/main.scr::changeGameType"
	local.prevThreadName 	= parm.previousthread.threadName
	if (local.prevThreadName == NIL){
		local.prevThreadName = "unknown location"
	}
	thread changeGameTypeDebug ("(" + local.threadName + "): Called from " + local.prevThreadName)

	//just in case we don't want any further gametype changes (e.g. map load)
	if (level.coop_preventGameTypeChanges){
		thread changeGameTypeDebug ("(" + local.threadName + "): Tried to run while gametype changes are disallowed. Stopping...")
		end
	}

	if (local.wait == NIL){ local.wait = 0 }

	//force a context switch as this function cannot run concurrently
	if (level.coop_changeGameTypeThread){
		thread changeGameTypeDebug ("(" + local.threadName + "): Tried to run concurrently at " + level.time + ". Not allowed! Waiting until changeGameType called from " + level.coop_changeGameTypeThread.prevThreadName + " has finished...")
		while (level.coop_changeGameTypeThread){ wait game.ms }
		thread changeGameTypeDebug ("(" + local.threadName + "): Thread finished at " + level.time + ". Continuing...")
		//just in case we don't want any further gametype changes (e.g. map load)
		if (level.coop_preventGameTypeChanges){
			thread changeGameTypeDebug ("(" + local.threadName + "): Tried to run while gametype changes are disallowed. Stopping...")
			end
		}
	}
	level.coop_changeGameTypeThread = local

	if (local.wait && local.wait > 0){ wait local.wait }
	setcvar "g_gametype" local.gType

	if (local.gType == 2){
		thread changeGameTypeDebug ("(" + local.threadName + "): Gametype reset to 2 after a wait of " + (local.wait * 1000.0) + "ms")
	}else{
		thread changeGameTypeDebug ("(" + local.threadName + "): Gametype temporarily changed to " + local.gType + ".")
	}
}end

//[200] Smithy - debug messages for our gametype hack
//=========================================================================
changeGameTypeDebug local.message:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/changeGameTypeDebug->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if (level.coop_changeGameTypeDebug){ println local.message }
}end

//[200] Smithy
//used by other scripts to wait until main.scr::main has loaded.
//uses a waittill event as we cannot be sure how many instances
//will need this when, say, aihandler or itemhandler is waiting before prespawn.
//e.g. stops us having to add many, many loops for many, many BSP items.
//99% of the time this will only trigger for BSP items.
//Note: this can be used by any future scripts (use waitthread)
//=========================================================================
waitForMainScript:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/waitForMainScript->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if (level.time != 0.000){ end } //[200] Smithy 
									//fixes crashes when this func is called when server unloads map (map change, disconnect etc)...
 									//Why is it called on unload? Apparenty an object spawns and gets picked up by my itemhandler according to logs...
 									//Why does it crash? Probably because level. var that checks that main has loaded becomes uninitialised
 									//during unload procedure. So it waits here indefinitely and the game just doesn't like that.
 									//As mainScriptLoaded event is only ever needed before prespawn for bsp items, level.time will be 0.000
 									//As such, if it is not 0.000, it is an invalid call, and as such we end it here. This solves the issue.


	local.threadName 		= "coop_mod/main.scr::waitForMainScript"
	local.prevThreadName 	= parm.previousthread.threadName
	local.prevSelf 			= parm.previousthread.self 	//grab the self object the previous thread is processing for
	if (local.prevSelf){ 							 	//better reporting
		local.prevSelf = (" with object " + local.prevSelf.classname)
	}
	if (local.prevThreadName == NIL){
		local.prevThreadName = "UNKNOWN"
	}
	if (!level.coop_mainScriptLoaded){
		if (level.coop_waitingForMainThreads == NIL){		
			level.coop_waitingForMainThreads = 0 		//number of threads waiting for main to load
		}
		level.coop_waitingForMainThreads++
		//println "(" local.threadName "): main.scr wasn't loaded in time for (" local.prevThreadName ") to process" local.prevSelf " at " level.time ". Thread " level.coop_waitingForMainThreads " is waiting..." //better reporting
		//[202] chrissstrahl - disabled debug message and added a Warning Output
		if(level.coop_waitingForMainThread && level.coop_waitingForMainThread > 50){
			println ("COOP WARNING: main.scr wasn't loaded in time for "+level.coop_waitingForMainThreads+" Threads")
			println ("This is unusual, make sure main.scr is included in the primary level script file at the very top.")
		}
		
		waitthread coop_mod/eventsystem.scr::waitTillEvent "mainScriptLoaded"
	}
}end

//[200] Smithy - use this if you want a static localised earthquake
//will affect all players in the radius
//e.g. thread coop_mod/main.scr::earthquake_local local.ent.origin 10 .4 256
//=========================================================================
earthquake_radius local.origin local.duration local.magnitude local.radius:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/earthquake_radius->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if (level.gametype == 0){ end }

	local.decay = local.magnitude / local.duration

	local.earthquake = spawn ViewJitter
	local.earthquake origin 		local.origin
	local.earthquake donedeath 		game.true 	//removes after firing
	local.earthquake edgeeffect 	1.0
	local.earthquake duration 		local.duration
	local.earthquake jitteramount 	( local.magnitude local.magnitude (local.magnitude * 1.5) )
	local.earthquake timedecay 		( local.decay  local.decay  local.decay )
	local.earthquake radius 		local.radius	
	local.earthquake triggereffect 	$world 		//do the jitter

}end

//[200] Smithy - use this if you want an earthquake to run for a specific player
//e.g. local.player thread coop_mod/main.scr::earthquake_player 10 .4
//=========================================================================
earthquake_player local.duration local.magnitude:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/earthquake_player->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if (level.gametype == 0 || !self){ end }

	local.player = self

	local.decay = local.magnitude / local.duration

	local.earthquake = spawn ViewJitter
	local.earthquake donedeath 		game.true 			//removes after firing
	local.earthquake edgeeffect 	1.0
	local.earthquake duration 		local.duration
	local.earthquake jitteramount 	( local.magnitude local.magnitude (local.magnitude * 1.5) )
	local.earthquake timedecay 		( local.decay  local.decay  ((local.magnitude * 1.5) / local.duration))
	local.earthquake radius 		96	
	local.earthquake triggereffect 	local.player 		//do the jitter

	//attach it to player
	//i won't use glue/bind as the engine has MAX_GLUE_CHILDREN of 8 per ent and it could mess up scripts
	while (local.earthquake && isAlive local.player && local.player.dmteam != "spectator"){
		local.earthquake origin local.player.origin
		waitframe
	}

	if (local.earthquake){
		local.earthquake delete
	}
}end

//[200] Smithy - restart the current map
//=========================================================================
restartMap:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/restartMap->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.mapname = getcvar "mapname"

	//[200] chrissstrahl - i think this way it is better scalable
	if (waitthread containsText local.mapname "$"){
		local.mapname = waitthread cleanText local.mapname "$"
	}else{
		local.mapname = (local.mapname+"$")
	}
	
	thread loadMap local.mapname game.true
}end

//[200] Smithy - load a map
//=========================================================================
loadMap local.name local.skipFade:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/loadMap->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	thread disableGameTypeChanges
	//[200] chrissstrahl - lets use the default way of loading next map
	exec global/missioncomplete.scr local.name bsp2bsp local.skipFade
}end

//[200] Smithy - global disabling of changeGameType hacks
//=========================================================================
disableGameTypeChanges:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/disableGameTypeChanges->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.threadName = "coop_mod/main.scr::disableGameTypeHacks"
	level.coop_preventGameTypeChanges = game.true 				//[200] Smithy - stop any further changes via main.scr::changeGameType if there are any
	if (level.coop_changeGameTypeThread){  						//[200] Smithy - stop the thread if one is running					
		thread changeGameTypeDebug ("(" + local.threadName + "): Terminating " + level.coop_changeGameTypeThread.threadName + " thread for level change, and stopping any future calls.")
		level.coop_changeGameTypeThread end
	}
}end

//[200] Smithy - returns the client with this entnum
//could use getentbyentnum but this is more compatible with SH
//=========================================================================
getClient local.num:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/getClient->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if ($player){
		local.maxClients = level.coop_svmaxclients
		for (local.i = 0; local.i <= local.maxClients; local.i++){
			local.index = local.i + 1
			if (!$player[local.index]){ break }
			if ($player[local.index].entnum == local.num){
				end($player[local.index])
			}
		}	
	}
}end(NULL)

//[200] Smithy - check if we are in coop or not...
//we use this for files that share both SP and MP maps
//e.g. global/ scripts
//=========================================================================
inCoopMode:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/inCoopMode->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if (level.gametype == NIL){ level.gametype = int(getcvar "g_gametype") } //just in case level.gametype isn't a var yet

	local.isCoopMap = waitthread coop_mod/main.scr::isCoopEnabledMap (getcvar "mapname")

}end(local.isCoopMap && level.gametype)
	

//[200] Smithy - check that the map is one that supports coop mod.
//We can add custom map support to here later (e.g. 'coop_' prefix)
//=========================================================================
isCoopEnabledMap local.map:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/isCoopEnabledMap->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//[200] chrissstrahl - lets upgrade this a bit, make sure to reduce errors
	//[200] Smithy - improved further - moved extra checks inside the return as breaks (that were required now extra checks were added) were missing
	
	if(local.map.size < 4){ end game.false }
	
	switch (local.map[0]){		
		case m: //missions pattern m1l,e1l,t1l
		case e:
		case t: 													//[200] Smithy - dont need uppercase checks (we dont do that anywhere else here, and getcvar command passes map name into here...)
			end(local.map[2] == "l" && bool(string(local.map[1])) || local.map == "training") //[202] chrissstrahl - added training level	//[200] Smithy - this is nicer - it will return 0 if a letter or 0, returns 1 if an int higher than 0
		case b: //briefings
			end(local.map[1] == "r" && waitthread containsText local.map "iefing") //for extra efficiency we can add optional index pos as an arg
		case c: //coop_ maps
			end(local.map.size > 5 && local.map[4] == "_" && waitthread containsText local.map "coop_") //[200] Smithy - '_' check is nicer - plus previous check was for '0' not 'o'
	} 		//[200] Smithy ^^ - size check to fix potential index issue raised by Chris (has to be more than 5 due to coop_ prefix)
}end(game.false)

//[202] chrissstrahl - cleans the mapname of savepoints ($...) and returns it
//=========================================================================
getCleanMapname local.dirtyName:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread main/getCleanMapname->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.fullMapName = string(local.dirtyName);
	local.cleanName = ""
	for(local.current = 0; local.current < local.fullMapName.size;local.current++){
		if(local.fullMapName[local.current] == "$"){ break }
		local.cleanName += local.fullMapName[local.current]
	}
}end local.cleanName

