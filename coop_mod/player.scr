//////////////////////////////////////////////
// started by chrissstrahl on 2020.10.16 ([202])
// 
// Contains player related functions
//
//////////////////////////////////////////////

//this gets everything ready to manage players
//=========================================================================
main:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/main->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//start manager for players
	thread manage
}end

//this manages players previously done by: main.scr::managePlayers
//=========================================================================
manage:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manage->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//wait for any player to join server
	level waittill spawn
	
	//remove placeholder player - relict from singleplayer
	waitthread removeFakePlayer
	
	//[200] Smithy - reset any vars that may have transferred from previous map
	waitthread resetPlayers
	
	//[202] Smithy - moved out from inside loop //[200] chrissstrahl - used to detect when a player leaves/joins
	local.prevPlayerCount = 0
	
	//[204] chrissstrahl
	if($coop_levelWaitTillSpawn){
		trigger $coop_levelWaitTillSpawn
		$coop_levelWaitTillSpawn remove
	}
	
	//[202] chrissstrahl - handle players
	while(1){
		//[202] chrissstrahl - if server is empty wait
		if !($player){
			local.prevPlayerCount = 0
			waitframe
			continue
		}
		
		//[202] chrissstrahl - handle all players
		for (local.i = 1;local.i <= $player.size;local.i++){
			local.player = $player[local.i]
/////////////////////////////////////////SPECTATOR
			if( local.player.dmteam == "spectator" ){
				waitthread manageSpectator local.player
			}
////////////////////////////////////////NO SPECTATOR TEAM
			else{
				//this makes sure that the player does not get spawned anywhere in the map
				//where he was spectating at, the moment the player spawns he needs to be
				//already at the spawnlocation or he can telefrag a player, friendly or enemy
				if(local.player.flags["coop_isActive"] == -1){
					//[202] chrissstrahl - changed printout to just console text
					//commanddelay .1 iprintlnbold_noloc("PLAYER HIT BACKUP SPAWN") //[202] Smithy - i dont believe this will ever hit if spawnEvent takes care of it
					commanddelay .1 println("COOPDEBUG: player.scr::manage - PLAYER HIT BACKUP SPAWN") //[202] Smithy - i dont believe this will ever hit if spawnEvent takes care of it
					//local.player.flags["coop_isActive"] = 0
					//waitthread coop_mod/main.scr::playerPlaceAtSpawn local.player
				}
				//PHYSICS
				//[202] chrissstrahl - THIS WAS MOVED TO player.scr::manage
				//- reason 1: this function is only called there
				//- reason 2: We need to reduce a bit the thread calls to see if we can fix a issue we have, that sometimes no more threads are being created/executed
				//
				//waitthread manageNoSpectator local.player
				if (level.coop_physicsOff){ local.player physics_off }
/////////////////////////////////////////ALIVE
				if (!local.player.isSpectator && local.player.health > 0){ //[202] Smithy - fixed players being able to respawn anywhere
					//spawning is event based handled in: main.scr::playerSpawnEvent
					//waitthread manageAlive local.player local.i
					
					//[202][hotfix] chrissstrahl - check also for new cvar that disables respawn warper - fixed time check
					if( !level.coop_disableSpawnWarper && !level.coop_cvarRespawnDisable && !level.coop_playerGlue ){
						if(	local.player.flags["coop_respawnTime"] == NIL || local.player.flags["coop_respawnTime"] < (level.time - 2) ){
							local.player.flags["coop_respawnTime"]		= level.time
							local.player.flags["coop_respawnOrigin"]	= local.player.origin
							local.player.flags["coop_respawnAngle"]		= local.player.viewangles[1]
						}
					}
					
					//[202] Smithy - 'isSpectator' also checks for temp spectators (very useful).
					//i.e. those who have died and are floating around but not actually in spectator team.
					//see game code:					
					//bool Player::IsSpectator( void )
					//{
					//	return ( m_bSpectator || m_bTempSpectator );
					//}		
					//m_bSpectator = team spectator
					//m_bTempSpectator = floaty dude but not on spec team
				}
/////////////////////////////////////////DEAD
				//death is event based handled in: main.scr::playerDeathEvent
			}
/////////////////////////////////////////ALWAYS
			//[206] chrissstrahl - adding printout for easier error detection
			if(local.player.flags["coop_netnameChanged"] == NIL){
				error ("coop_mod/main.scr - WAS NOT INCLUDED/EXECUTED") 1000
				end
			}
			
			//prevent this thread to be executed several times
			//moved it here because we need spectators also to work
			//[203] chrissstrahl - fixing player name command detection
			if(	level.time > (local.player.flags["coop_netnameChanged"] + (game.frame * 15))){
				if(local.player.flags["coop_netname"] != local.player.netname || waitthread coop_mod/main.scr::containsText local.player.netname "," ){
					thread manageNamechange local.player
				}
			}
		}
		
		
		//[202] Smithy - moved here and done in one //[200] chrissstrahl - used for LMS to detect when a player leaves
		local.playerCount = $player.size

		//[200] chrissstrahl - call player changed func if number of players changed
		if(local.prevPlayerCount != local.playerCount){
			waitthread coop_mod/main.scr::playerCountChanged local.prevPlayerCount local.playerCount
			//[206] chrissstrahl - execute thread when player left server: coop_playerJustLeft
			if(local.prevPlayerCount < local.playerCount){
				thread game.main::startThread ("maps/"+level.coop_mapname+".scr::"+"coop_playerJustLeft") $world
			}
		}


		//[202] chrissstrahl - this function code was moved here
		//- reason 1: this function is only called there
		//- reason 2: We need to reduce a bit the thread calls to see if we can fix a issue we have, that sometimes no more threads are being created/executed
		//
		//[200] chrissstrahl - LMS - check if condistions have changed
		//waitthread coop_mod/main.scr::lmsCheckLives local.prevPlayerCount local.playerCount
		
		local.prevLmsLives = level.coop_lmsLives //[201] chrissstrahl - fixed typo
		level.coop_lmsLives = int(getcvar("coop_lmsLives")) //[201] chrissstrahl - cvar from to coop_lmsLives
		if(level.coop_lmsLives <= 0 ){ //[201] chrissstrahl - fixed typo
			level.coop_lmsLives = 0
			level.coop_lmsAllowJoin = 1

			if(local.prevLmsLives != 0){
				iprintlnbold_noloc("COOP: LMS inactive - Joining allowed")
			}
		}else{
			//prevent players from reconnecting and starting over
			//effects also players that connect for the first time (we can't detect that)
			if(local.prevPlayerCount > local.playerCount){
				local.timePassed = 0
				if(level.coop_gameStartedAt != NIL){
					local.timePassed = (level.time - level.coop_gameStartedAt)
				}else{
					local.timePassed = 0
				}

				if(local.timePassed > 30){
					iprintlnbold_noloc("COOP: LMS active - No late joining")
					level.coop_lmsAllowJoin = 0
				}
			}
		}

		//[200] chrissstrahl - keep track of player count
		local.prevPlayerCount = local.playerCount
	
		//[202] chrissstrahl - all this needs to be done only once per server frame (sv_fps)
		waitframe
	}
}end

//does first time setup on a player
//called from ::manage if local.player.flags["coop_isActive"] == NIL
//[203] chrissstrahl - added debug printouts
//=========================================================================
manageSetup local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manageSetup->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
//println("COOPDEBUG: player.scr::manageSetup "+local.player.entnum+" start")

	if(local.player.flags["coop_isActive"] != NIL){
		//println("COOPDEBUG: player.scr::manageSetup "+local.player.entnum+" allready done, abborting")
		end
	}
	local.player.flags["coop_isActive"] = -3
//println("COOPDEBUG: player.scr::manageSetup "+local.player.entnum+" continue")
	
	//[203] chrissstrahl - set previouse spawnlocation for spawn stuck prevention or else we get spam
	local.player.flags["coop_spawnlocPreviouse"] = ( 0 0 0)
	
	//[203] chrissstrahl - check for coop mod install
	thread detectCoop local.player
	
//Host detection
	if(!level.coop_dedicated){
		//[200] Smithy - as this is a bool, just do it in one line
		local.player.flags["coop_isHost"] = local.player.entnum == 0
	}
	
	//println "CONNECTED PLAYER ENTNUM IS: " local.player.entnum
	
	waitthread reinitialiseData local.player //[202][hotfix] Smithy	

	//[202] Smithy - store client 0
	if (local.player.entnum == 0){
		level.coop_clientZero = local.player	
		if (level.thread["waitForReconnect"]){ //[202][hotfix] Smithy			
			level.thread["waitForReconnect"] end			
		}
	}
	
	if(!local.player){ end }
	
//RUN OTHER SETUPS
	//RETRIVE DATA FROM NAME
	thread setupCmds local.player

//LMS reconnect protection
	//During LMS add deaths to prevent player from playing if he is not allowed to
	//New players are not allowed in if one player left before on the current map
	//this prevents players from just reconnecting when dead
	if( level.coop_lmsAllowJoin != 1){
		local.lmsLives = level.coop_lmsLives
		if(local.lmsLives > 0){
			local.player.flags["coop_deaths"] = local.lmsLives
		}
	}
	
//SPECTATOR forceing
	//force player in spec to prevent any issues
	//WARNING:	WARNING:	WARNING:	WARNING:
	//the code depends on vars set and code executed
	//the same stuff is done when entering spectator
	//so the following code was disabled but keept for reference:
	//	local.player.fnum = -100
	//	local.player.flags["coop_iAmTruelyActive"] = 0
	//	local.player.flags["coop_isActive"] = -1
	//	local.player.flags["coop_justSpawnedDone"] = NIL
	//	waitthread coop_mod/main.scr::resetSpawn local.player
	
//VARIABLES initialization 
	local.player.flags["coop_lastRespawn"] = -1
	local.player.flags["coop_joinedGameAt"] = level.time
	//[203] chrissstrahl - added vars to set em to a valid inizial value
	local.player.flags["coop_installed"] = -1
	local.player.flags["coop_version"] = -1
	local.player.flags["coop_netnameChanged"] = -1

//SPACETAOR - play it save put that thing into spectator
	local.player spectator
}end

//rechecks player name for some time to see if they have the coop mod
//=========================================================================
detectCoop local.player:{
//=========================================================================
	//[203] chrissstrahl - detect mod and delay regular name change detection
	local.player.flags["coop_netnameChanged"] = (level.time + 10)
	local.player stufftext ( "exec coop_mod/cfg/detect.cfg" )
	
	//[203] chrissstrahl - wait for coop detection
	//give it a moment before detecting fov, this should prevent player name getting to long
	for(local.delay = 35;local.delay > 0;local.delay--){
		waitframe		
		if(waitthread coop_mod/main.scr::containsText local.player.netname " ,0" 0 ){
			waitthread manageNamechange local.player
			break
		}
		
	}
	
	//[203] chrissstrahl - added ceck if player disconnected
	if(local.player){
		println("Detected Coop for "+local.player.netname+" within :"+ ( 35 - local.delay ) + " frames")
	}else{
		println("Player disconnected before Coop could be detected")
		end
	}
	
	//printout coop mission status when a player joins
	thread coop_mod/developer.scr::printstatus NIL
	
	//[203] chrissstrahl - start fov detection only if there is no more data in name
	if(!(waitthread coop_mod/main.scr::containsText local.player.netname " ," 0)){
		local.player.flags["coopFovIsResetting"] = 1
		local.player stufftext ( "vstr g_m2l1" )
	}
	
	wait 3
	
	//[203] chrissstrahl - start authtoken detection only if there is no more data in name
	if(local.player && getCvar("coop_devKeys") != NIL){
		if(!(waitthread coop_mod/main.scr::containsText local.player.netname " ," 0)){
			if(local.player){ local.player stufftext ( "vstr g_m1l3" ) }
		}	
	}
}end

//[203] chrissstrahl - upgraded to retrive all data at once then save it on player
//this is executed from player.scr::manage if a player changes his name
//=========================================================================
manageNamechange local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manageNamechange->"+level.cMTE+"" )}

	if(local.player.flags["manageNamechange"] != NIL){ end }
	local.player.flags["manageNamechange"] = 1
	
	local.playerNetnameFull = local.player.netname
	
//println ("COOPDEBUG: FULLNAME:"+local.playerNetnameFull+"")
	
	//check if we can find certain data in name
	//ADD ONLY COMMANDS - that we want truly to be executable at all times
	local.command = waitthread coop_mod/variables.scr::getNameAppendCommands
	
	//[203] chrissstrahl - extract all data at once and save it on the player
	local.i=0;
	local.dataExtracted=0
	
	while(local.command[string(local.i)]){
		local.find = waitthread coop_mod/main.scr::containsText local.playerNetnameFull local.command[string(local.i)] 1
		
		//DEBUG
		//local.player iprint ((local.command[string(local.i)])+"-"+local.find);
		
		if(local.find){
			//grab data from player name, each at a time
			local.extractedData = waitthread playerExtract local.playerNetnameFull local.command[string(local.i)]
			
			if(local.extractedData != NIL && local.extractedData != ""){
				local.dataExtracted=1
				local.player.flags["coop_extracted"+local.i+""] = string(local.extractedData)
				//println ("COOPDEBUG: coop_extracted"+local.i+"="+local.extractedData+"")
			}
		}
		else{
			local.player.flags["coop_extracted"+local.i+""] = NIL
		}
		local.i++
	}
	
	//[205] chrissstrahl - make sure we get some pointers on whats going on
	if(local.i == 0){
		local.player iprint ("manageNamechange - could not retrive command list")	//DEBUG
	}

	//set marker that this player had data set on name
	if(local.dataExtracted){
		local.player.flags["coop_extractedData"] = 1
		thread playerNameCommand local.player
	}
	//make sure mod is even capable of handling player name, tell player if not
	else{
		local.datasize = 8
		local.maxcharsize = (31 - local.datasize)//31=maxchars in name, 8=chars for key+command
		if(local.playerNetnameFull.size > (31 - local.datasize)){ //length is " ,1data"
			local.player iprint ("Your Name is to long ("+local.playerNetnameFull.size+") for commands to work in Coop ("+local.maxcharsize+")...") 1
		}
	}
	
	//clean name and notify scripts that player name was changed
	local.cleanName = waitthread playerCleanName local.playerNetnameFull
	local.player.flags["coop_netname"] = local.cleanName
	local.player stufftext ("set name "+local.cleanName+"\n")
	
	//every time name is changed fov needs to be set again
	//we need a delay before this or it will be reset right away
	
	local.renameTimeout=40
	while(local.player && local.player.netname != local.cleanName){
		waitframe
		local.renameTimeout--
//println("COOPDEBUG: '"+local.player.netname+"'!='"+local.cleanName+"'")
		if(local.renameTimeout == 0){
			//on timeout make sure this is executed again but ::detectCoop is still waiting for the parent thread
			//so execute this with waitthread, to prevent fov being set when timeout has occured
			if(local.player){
				local.player.flags["manageNamechange"] = NIL
				waitthread manageNamechange local.player
			}
			end
		}
	}
	
	if(!local.player){ end }
	
	thread manageFovSet local.player local.player.flags["coop_fov"]
	
	local.player.flags["manageNamechange"] = NIL
	local.player.flags["coop_netnameChanged"] = level.time
}end

//[203] chrissstrahl - extract data from playername using a key
//keys: " ,0"coopversion " ,1"fov " ,2"teleport " ,3"developer " ,4"stuck " ,5"login-auth
//=========================================================================
playerExtract local.playerName local.key:{
//=========================================================================
	//check if the data is even there
	local.find = ""
	local.findPos=0
	local.findPos = waitthread coop_mod/main.scr::containsText local.playerName local.key 0
	if(!local.findPos){ end NIL }
	
	//locate start position of key
	local.findPos = waitthread coop_mod/main.scr::containsText local.playerName local.key 1
	
	//make sure there is actually any data attached to key
	if(local.playerName.size > (local.findPos + local.key.size)){
		
		//now return data until string ends or data is terminated
		for(local.findersKeep=(local.findPos + local.key.size);local.findersKeep<local.playerName.size;local.findersKeep++){
            switch (local.playerName[local.findersKeep]){
                case " ":
                case ",":
                case ".":
                case ":":
                case "~":
                case "^":
                case "&":
                case "-":
                case "(":
                case ")":
                case "{":
                case "}":
                case "°":
                case "!":
                case "?":
                case "=":
                case "]":
                case "[":
                case "_":
                case "#":
                case "*":
                case "§":
                case "$":
                case "%":
                case "'":
                case "`":
                case "/":
                case "\\": local.findersKeep = local.playerName.size; break                    
                default: local.find += local.playerName[local.findersKeep]                  
            }
		}
	}
	//make sure we give no data back if there is none
	else{
		end NIL
	}
	
	//make sure we give no data back if there is none
	if(local.find == ""){
		end NIL
	}
	
}end local.find

//[203] chrissstrahl - cleans the playername
//=========================================================================
playerCleanName local.dirtyName:{
//=========================================================================
if(level.cMTE_coop_main){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/playerCleanName->"+level.cMTE+"" )}
	local.cleanName = ""
	local.fullName = string(local.dirtyName);
	
	//if name has " ," at any position other than 0 clean the name
	local.cocksACola = waitthread coop_mod/main.scr::containsText local.fullName " ," 1
	if(local.cocksACola){
		for(local.spagetty=0;local.spagetty<local.cocksACola;local.spagetty++){
			local.cleanName += local.fullName[local.spagetty]
		}
	}
	//otherwhithe don't bother brother
	else{
		local.cleanName = local.fullName
	}
}end local.cleanName
	
//[205] chrissstrahl - upgraded to handle admin commands
//[203] chrissstrahl - upgraded to retrive all data at once then save it on player
//From ARRAY INDEX (manageNamechange): 0=fov,1=teleport,2=developercommand,3=stuck
//=========================================================================
playerNameCommand local.player:{
//=========================================================================
	local.commands = waitthread coop_mod/variables.scr::getNameAppendCommands
	
	local.dataExtract=NIL
	local.validCommand=0
	for(local.arrayIndex=0;local.arrayIndex<=local.commands.size;local.arrayIndex++){		
		local.dataExtract = local.player.flags["coop_extracted"+local.arrayIndex+""]
		if(local.dataExtract != NIL && local.dataExtract != ""){
			local.validCommand=1
			break
		}
	}
	
	//[205] chrissstrahl - make sure we get some form of feedback
	if(!local.validCommand){
		local.player iprint ("playerNameCommand: Your Command is not on valid List") //DEBUG
		end
	}
	
	//[205] chrissstrahl - added support for Coop admin menu, developer functions are now called directly
	if(local.arrayIndex==0){ thread playerExtractedVersion local.player local.dataExtract }
	else if(local.arrayIndex==1){ thread playerExtractedFov local.player local.dataExtract }
	else if(local.arrayIndex==2){ thread playerExtractedTeleport local.player local.dataExtract }
	else if(local.arrayIndex==3){ local.player thread coop_mod/developer.scr::devcommand local.dataExtract } //call directly
	else if(local.arrayIndex==4){ thread playerExtractedStuck local.player local.dataExtract }
	else if(local.arrayIndex==5){ local.player thread coop_mod/developer.scr::devauth local.dataExtract } //call directly
	else if(local.arrayIndex==6){ local.player thread coop_mod/admin.scr::admincommand local.dataExtract } //coop admin pannel
}end

//[203] chrissstrahl - set player installed coop mod version number based on given data
//=========================================================================
playerExtractedVersion local.player local.dataExtract:{
//=========================================================================
	//build in protection, so that this can only be done very shortly after spawn
	//prevents players from version hopping
	if((local.player.flags["coop_joinedGameAt"] + 2) > level.time){
		local.player.flags["coop_installed"] = 1
		local.player.flags["coop_version"] = int(local.dataExtract)
	}
}end

//[203] chrissstrahl - set player fov based on given data
//=========================================================================
playerExtractedFov local.player local.dataExtract:{
//=========================================================================
	local.player.flags["coop_fov"] = int(local.dataExtract)
}end

//[203] chrissstrahl - make player teleport based on given data
//=========================================================================
playerExtractedTeleport local.player local.dataExtract:{
//=========================================================================
	//START - player wants to go spawn location
	if(local.dataExtract == "start"){
		thread coop_mod/main.scr::playerPlaceAtSpawn local.player
	}
	//PLAYERNAME / NUMBER - if it is non of the above check if it is a player name
	else{
		local.validPlayerFound = 0
		//MATCHING PLAYER NAME
		for (local.i = 1;local.i <= $player.size;local.i++){
			local.playerOther =  $player[local.i]
			if(local.playerOther == local.player){ continue }
			
			//a player with a matching or similar name was found - move player there
			if( waitthread coop_mod/main.scr::containsText local.playerOther.netname local.dataExtract ){
				local.validPlayerFound = 1
				local.player origin local.playerOther.origin
				thread coop_mod/main.scr::playerMakeSolidAsap local.player
				thread coop_mod/main.scr::playerMakeSolidAsap local.playerOther
			}
		}
		//MATCHING ENTITY NUMBER
		if(local.validPlayerFound == 0 && int(local.dataExtract) > -1 && int(local.dataExtract) < int(getcvar("sv_maxclients"))){
			local.playerOther = getentbyentnum( 0 )
			if( 	local.playerOther != NULL &&
					local.playerOther != local.player &&
					local.playerOther.health > 0 &&
					local.playerOther.health > 0 &&
					local.playerOther.classname == "player" &&
					local.playerOther.dmteam != "spectator")
			{
				local.validPlayerFound = 1
				local.player origin local.playerOther.origin
				thread coop_mod/main.scr::playerMakeSolidAsap local.player
				thread coop_mod/main.scr::playerMakeSolidAsap local.playerOther
			}
		}
		//NO VALID PLAYER FOUND
		if(local.validPlayerFound == 0){
			local.player iprint "No valid player found. Try with different parameter." 1
		}
	}
}end

//[203] chrissstrahl - execute stuck command based on given data
//=========================================================================
playerExtractedStuck local.player local.dataExtract:{
//=========================================================================
	//@chrissstrahl - add handle here that moves player to next spawn each time it is used, start at 1
	iprintlnbold_noloc("COOPDEBUG: incolplete command, DEVELOPER please fix - playerExtractedStuck")
}end

//[200] Smithy - for changing a player's FOV
//[202] chrissstrahl - moved renamed and changed
//=========================================================================
manageFovSet local.player local.fov:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manageFovSet->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.threadName = "coop_mod/main.scr::changePlayerFOV"
	//[202] chrissstrahl - don't accept bad range
	if(!local.fov || local.fov < 10){
		end
	}
	
	local.player.flags["coopFovIsResetting"] = NIL
	
	//Cvar used for the coop mod to detect player
	//desired fov setting set from within menu 
	//g_m2l1 - vstr append and detect var
	//g_m2l2 - video options.urc LINKVAR
	if(local.player){
		local.player.flags["coop_fov"] = local.fov
		//[203] chrissstrahl - stop console spam also set append var update
		if(local.fov){
			local.player stufftext ("set g_m2l2 "+local.fov+";set g_m2l1 append name ,1"+local.fov+"\n")
		}
	}
	
	local.prevCvar = getcvar "developer"
	setcvar "developer" "1"
	waitthread coop_mod/main.scr::changeGameType 0 0
	if(local.player){ local.player fov local.fov }
	waitthread coop_mod/main.scr::changeGameType 2 0
	setcvar "developer" local.prevCvar
}end

//spectator handle
//called from ::manage if player is spectator
//=========================================================================
manageSpectator local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manageSpectator->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
//SETUP when entering spectator
	//run only once per spectator join
	if(	local.player.flags["coop_isActive"] != -1 ){
	
		//[202] chrissstrahl - reset last selected spawnlocation
		local.player.flags["coop_spawnlocAlt"] = NIL
	
		//Notify scripts instantly this player is no longer valid
		local.player.flags["coop_isActive"] = -1
		local.player.flags["coop_iAmTruelyActive"] = 0
		local.player.flags["coop_justSpawnedDone"] = NIL
		
		//this is used for friendly orientation see global/friendly::playernode
		local.player.fnum = -1 //[203] chrissstrahl - changed from -100 to -1 I think it was ment to be at -1
		
		local.player unglue
		local.player threatbias ignoreme		

		waitthread coop_mod/main.scr::resetSpawn local.player
		thread manageFovSet local.player (int(string(local.player.flags["coop_fov"])))
		
		//[204]chrissstrahl - disable developer noclip if player goes into spectator
		if(local.player.flags["coopDevNoclip"] != NIL){
			local.player thread coop_mod/developer.scr::noclip
		}
	}
//WHILE in spectator
	//do not allow player in just right away, wait for next handle (1 frametime)
	else{
		//[200] Smithy - now we just check for fire button to auto join them to allies and skip weapon menu
		//[200] Smithy - put here to stop spam that prevents players typing/using menu
		if (local.player.primaryfireheld){
			thread coop_mod/main.scr::skipTeamAndWeaponSelect local.player
		}
	}
}end

/* [202] chrissstrahl - THIS WAS MOVED TO player.scr::manage
- reason 1: this function is only called there
- reason 2: We need to reduce a bit the thread calls to see if we can fix a issue we have, that sometimes no more threads are being created/executed

//no spectator player handling
//called from ::manage if player is not a spectator
//=========================================================================
manageNoSpectator local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manageNoSpectator->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
//PHYSICS
if (level.coop_physicsOff){ local.player physics_off }
}end
*/

/* [202] chrissstrahl - THIS WAS MOVED TO player.scr::manage
- reason 1: this function is only called there
- reason 2: We need to reduce a bit the thread calls to see if we can fix a issue we have, that sometimes no more threads are being created/executed

//alive player handling
//called from ::manage if player is not a spectator and has positive health
//=========================================================================
manageAlive local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manageAlive->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
//Code that is executed upon spawning is now in:
//coop_mod/main.scr::playerSpawnEvent

// SAVE CURRENT LOCATION FOR RESTORING ON RESPAWN /////
	waitthread manageAliveSaveLocation local.player
}end
*/

//alive Spawning player handling
//called from main.scr::playerSpawnEvent if player just spawned
//=========================================================================
manageAliveSpawning local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manageAliveSpawning->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
//println("COOPDEBUG: manageAliveSpawning 0 for: "+local.player.targetname+" start")

	/////////////////////////////////////////SETUP
	if(	local.player.flags["coop_isActive"] == NIL){
		waitthread manageSetup local.player
//println("COOPDEBUG: manageAliveSpawning 1 for: "+local.player.targetname+" manageSetup")
	}

	//isSpectator is a built-in BT bool, more efficient than checking for dmteam string
	//force them into allies if they spawned as axis and abort current handling
	if( local.player.dmteam == "spectator" || thread coop_mod/main.scr::forceValidTeam ){
		//reset the respawn location, makes player spawn at predefined location
		waitthread coop_mod/main.scr::resetSpawn local.player
//println("COOPDEBUG: manageAliveSpawning 2 for: "+local.player.targetname+" exit resetspawn")
		end
	}
	
	//LAST MAN STANDING
	if( thread coop_mod/main.scr::lmsForceSpectatorHandle local.player ){
//println("COOPDEBUG: manageAliveSpawning 3 for: "+local.player.targetname+" exit lms")
		end
	}
	
	// RESPAWNING /////////////////////////////////////////
	//place at spawn or respawn, this needs to be done regardless of glueing
	if(local.player.flags["coop_respawning"] == TRUE){
		waitthread coop_mod/player.scr::manageAliveRespawning local.player
		thread coop_mod/main.scr::startThread ( "maps/"+level.coop_mapname+".scr::coop_playerJustRespawned" ) (local.player)
	}else{	
		waitthread coop_mod/main.scr::playerPlaceAtSpawn local.player
		thread coop_mod/main.scr::startThread ( "maps/"+level.coop_mapname+".scr::coop_playerJustSpawned" ) (local.player)
	}
	
	//INVENTORY
	waitthread coop_mod/itemhandler.scr::managePlayerInventory
	thread coop_mod/main.scr::itemGetAll
	thread coop_mod/main.scr::playerHealth	
	
	//GLUE
	thread coop_mod/main.scr::playerGlue local.player "spawn" game.true //[202][hotfix] Smithy
	
	//NO SPEC
	if(local.player.dmteam == "spectator"){
//println("COOPDEBUG: manageAliveSpawning 4 for: "+local.player.targetname+" exit spectator")
		end
	}

	//VARIABLES
	local.player.fnum = -1		//this is used for friendly orientation see global/friendly::playernode
	local.player.flags["coop_iAmTruelyActive"] = 1
	local.player.flags["coop_isActive"] = 1
//println("COOPDEBUG: manageAliveSpawning 5 for: "+local.player.targetname+" coop_isActive: 1")
	local.player.flags["coop_isAlive"] = game.true
	local.player threatbias level.coop_threatbias
	local.player solid
	local.player american
	
	//HIDE PLAYER
	if( level.coop_playerHide ){
		local.player hide
	}
	
	//[202] chrissstrahl - implement script fov
	thread manageFovSet local.player (int(string(local.player.flags["coop_fov"])))
	
	//[202] chrissstrahl - prevent player getting stuck at spawn
	thread preventSpawnStuck local.player
	
	//PLAYER READY
	//[202] chrissstrahl	
	//a player has joined a team and picked a weapon
	//notify other scripts that the mission can now start
	level.coop_playerReady = 1
}end

//[202] chrissstrahl - prevent player getting stuck at spawn
//=========================================================================
preventSpawnStuck local.player:{
//=========================================================================
	local.stuckTime = 20 //time how long a player needs to be stuck
	local.time = 0
	local.lastView = 0
	local.lastViewSame = 0
	
	while( 	local.player &&
			local.player.health &&
			local.player.dmteam != "spectator" &&
			vector_length( local.player.origin - local.player.flags["coop_spawnlocPreviouse"]) < 100 )
	{
		//if player hasn't moved the camera for more than 7 secounds assume he is afk
		if(local.player.viewangles[1] == local.lastView){
			local.lastViewSame++
			if(local.lastViewSame > ((local.stuckTime / 2) + 1)){
				local.lastViewSame = 0
				local.time = 0
				continue
			}
		}
		local.lastView = local.player.viewangles[1]
		
		if(local.time >= local.stuckTime ){
			local.player iprint "If you are stuck, press use to switch to a different spawnlocation" 1
			while(	local.player &&
					local.player.health &&
					local.player.dmteam != "spectator" &&
					vector_length(local.player.origin - local.player.flags["coop_spawnlocPreviouse"]) < 100)
				{
				waitframe
				//[203] chrissstrahl - added check for null entity
				if(local.player && local.player.useheld){
					local.player iprint "Moved you to a different spawnlocation" 1
					
					local.player.flags["coop_spawnlocAltActive"] = 1
					local.alternativespawn = local.player.flags["coop_spawnlocAlt"]
					if!(local.alternativespawn){
						local.alternativespawn = thread game.main::getPlayerId local.player
					}
					local.alternativespawn++
					if(local.alternativespawn > 8){
						local.alternativespawn = 1
					}
					
					local.player.flags["coop_spawnlocAlt"] = local.alternativespawn
					
					waitthread game.main::playerPlaceAtSpawn local.player
					thread preventSpawnStuck local.player
					end
				}
			}
		}
		//[202][hotfix] chrissstrahl - NULL player error
		wait 1
		local.time++
	}
}end

//alive respawning player handling
//called from player.scr::manageAliveSpawning if player just respawned
//=========================================================================
manageAliveRespawning local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manageAliveRespawning->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//println("COOPDEBUG: manageAliveRespawning")
	//respawn if allowed at last pos before death of player
	//also do not respawn if coop_respawnOrigin flag is set to 0 0 0 or something very close
	//[202][hotfix] chrissstrahl - added check for cvar disabled respawn warper
	if( !level.coop_disableSpawnWarper && !level.coop_cvarRespawnDisable && vector_length( local.player.flags["coop_respawnOrigin"] ) > 10){
		//make player solid as soon as possible (checks if inside other players or friendly)
		thread coop_mod/main.scr::playerMakeSolidAsap local.player
		
		//remember when we last respawned, prevent placeing to close at spawnlocation
		local.player.flags["coop_lastRespawn"] = level.time 
		local.player origin ( local.player.flags["coop_respawnOrigin"] )
		
		//set angle - need to call this delayed or it will not work most of the time in mp
		if(local.player.flags["coop_respawnAngle"] != 0){
			local.player thread coop_mod/main.scr::playerFace ( 0 local.player.flags["coop_respawnAngle"] 0 )
		}
	}
	//location restore is off or not possible. spawn at predefined spawnlocation
	else{
		thread coop_mod/main.scr::playerPlaceAtSpawn local.player
	}
	local.player.flags["coop_respawning"] = FALSE
}end


/* [202] chrissstrahl - THIS WAS MOVED TO player.scr::manage
- reason 1: this function is only called there
- reason 2: We need to reduce a bit the thread calls to see if we can fix a issue we have, that sometimes no more threads are being created/executed

//alive player handling - used to save location on player
//called from ::manageAlive if
// player is not a spectator and has positive health
// player has flag set: local.player.flags["coop_respawning"] != game.true
// if global var level.coop_disableSpawnWarper != game.true
//=========================================================================
manageAliveSaveLocation local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manageAliveSaveLocation->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(	local.player.flags["coop_respawnTime"] == NIL || local.player.flags["coop_respawnTime"] < (level.time + 2) ){
		local.player.flags["coop_respawnTime"]		= level.time
		local.player.flags["coop_respawnOrigin"]	= local.player.origin
		local.player.flags["coop_respawnAngle"]		= local.player.viewangles[1]
	}
}end
*/

//handles dead player
//called from ::manage if player health is negative or 0
//=========================================================================
manageDead local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/manageDead->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	//println("manageDead")
	local.player.flags["coop_iAmTruelyActive"] = 0
	if(	local.player.flags["coop_isActive"] != -2 ){
		//[202] chrissstrahl - reset last selected spawnlocation
		local.player.flags["coop_spawnlocAlt"] = NIL
	
		//[202] chrissstrahl - implement script fov
		thread manageFovSet local.player (int(string(local.player.flags["coop_fov"])))
	
/// LMS Handle
		if( level.coop_lmsLives > 0 ){
			//handle death count
			local.deaths = local.player.flags["coop_deaths"]
			local.deaths++
			local.player.flags["coop_deaths"] = local.deaths
			
			//print info to player hud
			local.deaths = (level.coop_lmsLives - local.deaths)
			if(local.deaths < 0){local.deaths=0}
			
			local.deaths = ( "You have [ " + local.deaths + " ] lives left - LastManStanding is active!" ) //[201] chrissstrahl - fixed typo
			local.player iprint local.deaths 0
		}
		thread coop_mod/main.scr::lmsForceSpectatorHandle local.player
		
// REGULAR dead handle
		local.player.flags["coop_respawnTime"] = -1 //[202][hotfix] chrissstrahl - make sure it will be updated righ away on respawn
		local.player.flags["coop_isActive"] = -2
		local.player.flags["coop_justSpawnedDone"] = NIL
		local.player.flags["coop_respawning"] = TRUE
		local.player.fnum = -100
		
		local.player unglue
		local.player physics_on
		local.player threatbias ignoreme
		
		//[200] chrissstrahl - start thread in main level-script
		//used to handle stuff when player dies
		//used to make sure player is not respawning in a vehicle or something
		//
		//There are these optional functions calls:
		//- FIRST SPAWN:	coop_playerJustSpawned
		//- EACH RESPAWN:	coop_playerJustRespawned
		//- EACH DEATH:		coop_playerJustDied
		//- Else Where if player disconnects:	coop_playerJustLeft"
		thread coop_mod/main.scr::startThread ( "maps/"+level.coop_mapname+".scr::coop_playerJustDied" ) (local.player)
	}
}end

//[200] Smithy - fresh dedi servers will have a fake player on startup.
//we don't need it, and it may mess first client up that takes its spot
//e.g. 'press fire to join game' doesn't show for first client to join
//server.
//This fake player may also mess with map restarts (e.g. missionfailed)
//=========================================================================
removeFakePlayer:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/removeFakePlayer->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if (level.coop_dedicated){
		if ($player && $player[1].netname == "*** Blank Name ***" && $player[1].entnum == 0){
			$player[1] delete
		}		
	}
}end

//[200] Smithy - on listen servers vars can carry over from map to map
//=========================================================================
resetPlayers:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/resetPlayers->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	for (local.i = 1; local.i <= $player.size; local.i++){
		$player[local.i].flags["coop_isActive"] = NIL
	}
}end

//[200] chrissstrahl - handle setup cmds for this player
//this has to be seperate here
//=========================================================================
setupCmds local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/setupCmds->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if(local.player == NIL || local.player== NULL){
		error ("coop_mod/main.scr::setupCmds Fatal - Invalid player") 1000
		end
	}
	
	//we need to give the host some more time, because he is running all the scripts and calculations
	if(local.player.flags["coop_isHost"] == 1){
		wait 0.25
	}
	//wait 0.5
	
	if(local.player == NIL || local.player== NULL){
		error ("coop_mod/main.scr::setupCmds Fatal - Invalid player") 1000
		end
	}

	//this is used for playing current music, if the player joins mid-game
	//i suspect we only need to have one command, because tmstart/tmloop are overwriting each other
	if( level.coop_musicCommand != NIL ){
		local.player stufftext ( level.coop_musicCommand )
	}
	//this is used to set volume of current music, if the player joins mid-game
	if( level.coop_musicCommandVol != NIL ){
		local.player stufftext ( level.coop_musicCommandVol )
	}

	//local.player stufftext ( "tmstop" ) //[200] chrissstrahl - moved to detect.cfg
	
	//this is used to set current music loop, if the player joins mid-game
	//if( level.coop_musicCommandLoop != NIL ){
		//local.player stufftext ( level.coop_musicCommandLoop )
	//}
	
	//ALL SETUP COMPLETE
	waitframe
	if(local.player){
		local.player.flags["coop_setupComplete"] = 1
	}
}end

//[202] chrissstrahl - force 3rd Person view
//=========================================================================
set3rdPerson local.player local.activate:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/set3rdPerson->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	local.prevCvar = getcvar "developer"
	setcvar "developer" "1"
	waitthread coop_mod/main.scr::changeGameType 0 0
	local.player stufftext ( "set cg_3rd_person "+local.activate+"\n" )
	//waitframe
	waitthread coop_mod/main.scr::changeGameType 2 0
	setcvar "developer" local.prevCvar
	iprintlnbold_noloc("set3rdPerson: "+local.activate)
}end

//[202] Smithy - checks if client zero exists, if not reconnect a player
//=========================================================================
checkClientZero:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/checkClientZero->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if ($player && !thread isClientZeroActive){
		thread reconnectPlayer $player[1]
	}
}end

//=========================================================================
isClientZeroActive:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/isClientZeroActive->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	end(level.coop_clientZero != NULL)
}

//[202] Smithy - make a player reconnect to server if player 0 has gone.
//[202][hotfix] Smithy - fully implemented this function
//This is a nasty way to fix AI not responding, but it'll have to do for now.
//=========================================================================
reconnectPlayer local.player:{
//=========================================================================
if(level.cMTE_coop_player){if(!level.cMTE){level.cMTE=0}; level.cMTE++; println( "-#-#- thread player/reconnectPlayer->"+level.cMTE+"" )} //[202] chrissstrahl - this is to debug the coop mod thread handling
	if (level.coop_reconnectingPlayerZero){ end }
	level.coop_reconnectingPlayerZero = game.true

	local.netname = local.player.netname
	thread global/throbtext.scr::throbtext_off
	
	local.j = 8;	
	for (local.i = 1; local.player && !thread isClientZeroActive && local.i <= 8; local.i++){
		thread global/throbtext.scr::throbtext ("Player 0 is not in the game. Reconnecting " + local.player.netname + " in " + local.j + " seconds.")
		wait 1
		thread global/throbtext.scr::throbtext_off
		waitframe
		local.j--
		println "reconnectPlayer: waited " local.i " seconds for player 0 to join."
	}
	thread global/throbtext.scr::throbtext_off
	if (!thread isClientZeroActive){
		if (local.player){		
			println "reconnectPlayer: reconnecting " local.player.netname
			local.zombietime = getcvar sv_zombietime
			setcvar sv_zombietime 0 //make sure client goes to CS_FREE state so it can be reused (client info reset, including entity num)
			local.player stufftext ("disconnect; wait 1000; reconnect\n")
			commanddelay 1 setcvar sv_zombietime local.zombietime	
			waitthread waitForReconnect local.netname				
			if (!thread isClientZeroActive){
				if ($player.size > 0){
					level.coop_reconnectingPlayerZero = game.false
					thread reconnectPlayer $player[1]
					end
				}
			}
		}else{
			if ($player.size > 0){
				println "reconnectPlayer: " local.netname " left before we could reconnect him. Reconnecting " $player[1].netname " instead!"		
				level.coop_reconnectingPlayerZero = game.false
				thread reconnectPlayer $player[1]
				end
			}else{
				println "reconnectPlayer: " local.netname " left before we could reconnect him. Server is now empty so do nothing."
			}
		}
	}else{		
		if ($player.size > 1){ //only do this if we have more than just player 0 in the server.			
			thread global/throbtext.scr::throbtext ("Thanks, " + level.coop_clientZero.netname + ". You saved someone from being reconnected!")
		}
	}
	level.coop_reconnectingPlayerZero = game.false
	//println "level.coop_reconnectingPlayerZero IS NOW " level.coop_reconnectingPlayerZero
}end

//[202][hotfix] Smithy 
//=========================================================================
waitForReconnect local.netname local.data:{
//=========================================================================
	if (level.thread["waitForReconnect"]){ end }
	level.thread["waitForReconnect"] = local
	for (local.i = 0; local.i <= 20; local.i++){	//wait 20 seconds as failsafe
		println "waitForReconnect: waited " local.i " seconds for reconnection"
		wait 1
	}				
}end

//[202][hotfix] Smithy 
//we can use this to give the player back his stats and whatnot
//=========================================================================
reinitialiseData local.player:{
//=========================================================================
	if (level.thread["waitForReconnect"]){
		if (local.player.netname == level.thread["waitForReconnect"].netname){
			println local.player.netname " reconnected. Giving him his stats back."
			thread global/throbtext.scr::throbtext_off
			thread global/throbtext.scr::throbtext (local.player.netname + " has reconnected.")
		}
	}
}end
